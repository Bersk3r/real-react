# 리액트 팀에선 concurrent 모드를 오래전부터 준비해왔으며, 리액트 버전 16.0에 추가된 파이버(fiber) 구조체가 그 시작임
## 페이스북 홈페이지에 concurrent 모드를 적용하면서 완성도를 높이고 있음

# concurrent 모드 이전에는 렌더링을 한번 시작하면 중간에 멈출 수 없었음
## 따라서 컴포넌트의 갯수가 상당히 많은 경웨 렌더링을 시작하면 사용자의 마우스나 키보드 이벤트에 거의 반응할 수 없었음
## 리액트는 이렇게 처리할 일이 많은 상황에서도 사용자의 요청에 반응할 방법을 운영체제의 선점형 멀티 태스킹 개념에서 찾았음

# 운영체제는 하나의 프로그램이 CPU를 점유하지 못하도록 하기 위해 일정 시간이 지나면 실행 중인 프로그램을 멈추고 다른 프로그램을 실행시켜 주는데 이를 멀티 태스킹이라고 함
## 멀티태스킹을 하기 위해선 실행 중인 프로그램의 현재 상태를 저장하고, 나중에 다시 실행될 때 이전 상태를 복원할 방법이 필요함

# concurrent 모드에서는 렌더링 과정을 여러 개의 작업으로 나눠서 실행 중인 작업을 중단하거나 중단된 작업을 재개할 수 있음
## 실행 중인 작업을 중단하는 판단의 기준은 하기 두 가지임
### 작업이 일정 시간을 초과하거나, 현재 실행 중인 작업보다 우선 순위가 더 높은 작업이 들어오면 현재 작업을 중단함
## 따라서, concurrent 모드에서는 우선순위가 낮은 작업의 양이 많다고 하여도 사용자의 키보드 입력에 빠르게 반응할 수 있음

# 렌더링 작업별로 우선순위를 부여하면 높은 우선순위를 가진 작업을 먼저 처리함으로써 CPU를 효율적으로 사용할 수 있음
## 우선순위는 다양한 방식으로 결정될 수 있으며, 지금가지 드러난 정보를 토대로 세 방식으로 결정됨
##  첫 번째는 컴포넌트의 상탯값을 변경할 때, 사용자가 직접 우선 순위를 입력하는 것
### 해당 상탯값의 변경으로 시작되는 렌더링 작업은 입력된 우선 순위로 처리됨
### 현재는 우선순위를 숫자로 입력하는 것이 아니라 높은 우선순위일 때 호출하는 함수와 낮은 우선순위일 때 호출하는 함수를 실험적으로 제공하고 있음
## 두 번째는 이벤트 처리 함수별로 리액트가 자동으로 우선순위를 결정하는 것
### 대표적으로 onKeyDown 이벤트에는 높은 우선순위가 적용되고, onMouseOver 이벤트에는 낮은 우선순위가 적용됨
#### onKeyDown 이벤트 처리 함수에서 상탯값을 변경하면 그로 인해 시작되는 렌더링 작업은 높은 우선순위로 처리됨
#### 따라서 사용자가 키보드로 입력한 내용은 빠르게 화면에 표시될 수 있으나 마우스를 돔 요소 위에 올렸을 때 돔 요소의 배경색을 변경하는 작업은 다소 느리게 처리될 수 있음
## 세 번째는 화면에 보이지 않는 영역은 우선순위를 낮게 해서 나중에 처리하는 것
### 리액트는 화면에 보이는 요소를 먼저 렌더링하고 화면에 보이지 않는 요소는 나중에 렌더링함
### 화면에 보이지 않는 요소를 미리 렌더링함으로써 나중에 탭 전환 시 빠르게 화면을 보여줄 수 있음

# 컴포넌트의 초기값이 아래와 같다고 하자
***
backgroundColor = 'red'
name = 'mike'
***
## backgroundColor 상탯값은 onMouseOver 이벤트에서 변경되고, name 상탯값은 onKeyDown 이벤트에서 변경된다고 하면 backgroundColor 상탯값 변경은 낮은 우선순위로 처리되고, name 상탯값 변경은 높은 우선순위로 처리됨
## backgroundColor 상탯값이 blue로 변경된다고 하면 리액트가 상탯값 변경에 따른 렌더링을 하던 도중 name 상탯값이 변경됨
## 우선순위가 높은 작업이 들어왔으므로 그 때까지 하던 작업을 멈추고 name 상탯값 변경으로 인한 렌더링 작업을 먼저 끝냄
### 그 다음에는 잠시 멈추었던 backgroundColor 상탯값 변경으로 인한 렌더링 작업을 이어서 처리해야 함
### 그러나 name 상탯값 변경을 처리하면서 UI 구조 (가상 돔)이 변경되었으므로 이전에 backgroundColor 상탯값 변경을 위해 처리했던 작업을 그대로 이어서 진행해도 현재 돔에 반영할 수 없음
## 위 상황에서 리액트는 버전 관리 도구의 리베이스(rebase) 전략을 사용함 -> backgroundColor 상탯값 변경을 위한 작업의 시작 상태를 name 상탯값 변경이 완료된 상태로 바꾼 후 남은 작업을 이어서 처리함으로써

# 서스펜스(suspense)는 렌더링 과정에서 API 호출과 같은 비동기 처리를 지원하는 기능으로 이를 이용하면 서버로부터 데이터를 가져오는 코드와 받은 데이터를 화면에 렌더링하는 코드를 모두 컴포넌트 함수에서 작성할 수 있음
## 데이터를 가져오는 동안 사용자에게 적절한 시각 효과를 제공하지 않으면, 사용자는 프로그램이 멈췄다고 생각하기 쉬움
## 서스펜스는 비동기 처리가 완료될 때까지 로딩 애니메이션과 같은 시각 효과를 보여줄 방법을 제공함
## 비동기 처리가 진행 중일 때는 렌더링을 중단하고 사용자가 정의한 시각 효과를 보여줌
## 비동기 처리가 완료되면 중단했던 렌더링을 재개함

# 서스펜스는 리액트 버전 16.6부터 지원되지만, 해당 버전의 리액트는 동기 방식으로 렌더링하므로 서스펜스의 일부 기능만 사용이 가능함

# 특정 컴포넌트 파일 크기가 크고 항상 사용되는 것이 아닌 경우 필요할 때 다운 받는 것이 효율적임
## 특정 컴포넌트의 코드를 분할해서 비동기로 다운 받으면 사용자는 특정 컴포넌트를 제외한 나머지 내용을 빠르게 확인할 수 있음
### suspense 컴포넌트와 lazy 함수를 이용하면 도듈의 비동기 다운로드를 렌더링 과정에 자연스럽게 포함시킬 수 있음
### 브라우저에서 네트워크 항목을 확인해보면 특정 컴포넌트 파일의 코드를 비동기로 받는 것을 알 수 있음

# Suspence 컴포넌트 내부에서 렌더링 중간에 비동기 처리를 할 수 있음
## API 통신도 비동기 처리의 한 예임

# Suspence 컴포넌트 내부에서는 렌더링 중이더라도 API를 호출할 수 있음
## concurrent 모드로 동작하지 않는 리액트 버전에서는 비동기 렌더링을 지원하지 않으므로 렌더링 중에 비동기 처리가 발생하면 멈췄다가 나중에 중단된 부분부터 다시 사작할 수 없음
## 동기 렌더링에서의 Suspence는 fallback으로 입려된 컴포넌트가 바로 사용되고, 비동기 처리가 끝나면 다시 한번 렌더링됨

# react-cache는 렌더링 과정에서 비동기 처리를 지원하기 위해 리액트에서 제공하는 패키지임
## 아직 실험적인 단계인 경우엔 리액트에서 정식으로 지원하기 전에 프로덕션에 사용하지 않는 게 좋음
## read 메서드를 호출 했을 때 이미 받은 데이터가 있다면 그 데이터를 사용함
## 만약 받은 데이터가 없다면 fetchUser 함수가 실행되고, fetchUser 함수가 반환하는 프로미스 객체와 함꼐 예외를 발생시킴
## 프로미스 객체와 함께 예외가 발생하면 부모로 거슬러 올라가면서 가장 가까운 Suspence 컴포넌트를 찾음
## Suspence 컴포넌트는 내부 영역을 fallback으로 대체하고, 추후 프로미스가 처리됨 상태가 되면 다시 렌더링함


# lazy 함수로 생성한 컴포넌트도 비동기 처리가 시작되면 프로미스 객체와 함께 예외를 발생시킴
## Suspence 컴포넌트를 렌더링에서의 try catch 문으로 생각할 수 있음

