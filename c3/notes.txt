# UI 라이브러리인 리액트는 UI 데이터를 관리하는 방법을 제공
## UI 데이터는 컴포넌트 내부에서 관리되는 상탯값과 부모 컴포넌트에서 내려주는 속성 값으로 구성됨
### 리덕스와 같이 전역 데이터를 관리해주는 것도 리액트에 적용 시, 상탯값과 속성값을 이용
## UI 데이터가 변경되면 화면을 다시 그려야 함
### 리액트와 같은 UI 라이브러리가 없으면 변경할 때마다 직접 돔 요소를 수정해야 함
### 돔 요소를 수정하면 비즈니스 로직과 UI를 수정하는 코드가 뒤섞여져 코드가 복잡해짐
## 리액트는 화면을 그리는 모든 코드를 컴포넌트 함수에 선언형으로 작성하도록 만듦 
### 컴포넌트 함수를 이용하여 화면을 자동 갱신함
# 화면을 어떻게 그리는지 나타내는 코드를 명령형(imperative) 프로그래밍, 화면에 무엇을 그리는지 나타내는 것을 선언형(declarative) 프로그래밍이라고 함
## 명령형 프로그래밍은 돔을 직접 수정하면서 화면을 어떻게 그리는지 구체적으로 나타내므로 돔 환경이 아닌 곳에선 사용이 어려움
## 선언형 프로그래밍은 화면에 무엇을 그리지만 나타내므로 다양한 방식으로 그릴 수 있음
### 컴포넌트 함수가 반환하는 코드는 선언형으로 작성되므로 리액트는 돔 환경 뿐만이 아닌 모바일 네이티브 UI도 표현 가능
### 선언형 프로그래밍은 명령어 프로그래밍보다 추상화 단계가 높음 => 추상화 단계가 높을수록 비즈니스 로직에 좀 더 집중이 가능
# 훅에서는 배열 비구조화 문법을 자주 사용함
# 컴포넌트의 상탯값은 해당 컴포넌트가 관리하는 데이터이고, 컴포넌트의 속성 값은 부모 컴포넌트로부터 전달받는 데이터임
## 리액트에서 UI 데이터는 반드시 상탯값과 속성값으로 관리해야 함 => 그러지 않으면 UI 데이터가 변경되도 화면이 갱신되지 않을 수 있음
## 컴포넌트에 상탯값을 추가할 때는 useState 훅을 사용함
### useState 훅의 인자는 초깃값을 의미함
### useState 훅의 첫 번째 원소는 상탯값이고, 두 번째 원소는 상탯값 변경 함수임
## 속성값은 부모 컴포넌트가 전달해주는 데이터이고, 대부분의 경우 UI 데이터를 포함함
## 자식 컴포넌트는 부모 컴포넌트가 렌더링될 때마다 같이 렌더링되므로, 속상 값의 변경 사항이 바로 화면에 반영됨
# 속성값이 변경될 때에만 자식 컴포넌트가 렌더링되길 원하면 React.memo를 활용하면 됨
## memo 함수의 인수로 컴포넌트를 입력하면 컴포넌트의 속성 값이 변경되는 경우에만 렌더링을 진행함
# 같은 컴포넌트를 여러번 사용할 수 있으며, 사용된 각 컴포넌트는 상탯값을 위한 자신만의 메모리 공간이 존재하여 같은 컴포넌트라도 자신만의 상태 값이 존재함
# 속성값은 불변(immutable) 변수이지만 상탯값은 불변 변수가 아님
## 상탯값도 불변 변수로 관리하는 게 좋음
### 불변 변수로 관리하면 코드의 복잡도가 낮아지는 장점이 존재함
## 속성 값은 값을 변경하면 에러가 발생함
# 자식 컴포넌트에 전달되는 속성값은 상위 컴포넌트에서 관리하므로 수정하지 못하도록 되어 있음
## 자식 컴포넌트를 수정하려면 속성값에 대한 상탯값을 가진 컴포넌트에서 관리하는 상탯값 변경 함수를 이용해야 함
# 상탯값을 변경하더라도, 상탯값 변경 함수를 호출하지 않으면 리액트는 변경된 내용을 모름
## 이 때, 상태 값 변경 함수를 호출해도 화면은 갱신되지 않음
### 리액트는 상탯값 유무를 이전 값과의 단순 비교로 판단하는데 객체의 경우 참조 값이 그대로이므로 변경 사항이 없다고 판단함
# 컴포넌트 함수의 반환값은 하기와 같음
## 컴포넌트와 HTML에 정의된 모든 태그
## 문자열과 숫자
## 배열, 단 각 리액트 요소는 key 속성값을 갖고 있어야 함
## 프래그먼트 (Fragment)를 사용하면 배열을 사용하지 않고 여러 개의 요소를 표현 가능, 프래그먼트 내부의 리액트 요소엔 key 속성 값을 부여하지 않아도 되므로 배열보다 편함
## 바벨을 사용하면 프래그먼트를 축약하여 <></> 형태로 작성이 가능
## null이나 boolean 값을 반환하면 아무 것도 렌더링이 되지 않음
## 리액트 포털을 사용하면 컴포넌트의 현재 위치와 상관없이 특정 돔 요소에 렌더링이 가능함
# 컴포넌트 함수에서 Boolean 값을 반환할 수 있음
# 리액트 포털을 이용하여 특정 돔 요소에 리액트 요소를 렌더링할 수 있으며ㅑ, 해당 컴포넌트가 사용된 위치와 무관하게 렌더링할 위치를 선택 가능함
# 리액트 요소 (React Element)는 리액트가 UI를 표현하는 수단으로 JSX 문법을 사용하므로 리액트 요소에 대한 내용을 잘 모름
## 리액트 요소를 이해하면 리액트 내부 동작 과정을 알 수 있음
## 리액트는 렌더링 성능을 위해 가상 돔을 활용함 
### 브라우저에서 돔을 변경하는 건 비교적 오래 걸리는 작업임
### 빠른 렌더링을 위해선 돔 변경을 최소화하는 게 중요하며 리액트는 메모리에 가상 돔을 올려놓고 이전과 이후의 가상 돔을 비교하여 변경된 부분만 실제 돔에 반영하는 전략을 채택함
# JSX 문법으로 작성된 코드는 createElement 함수로 변경되며, 이 함수는 리액트 요소로를 반환함 
# JSX에서 컴포넌트가 사용되면, 리액트 요소의 type 속성 값은 해당 컴포넌트 함수가 됨
# 리액트는 type 속성 값으로 전달된 함수를 호출해서 화면을 그리기 위한 충분한 정보를 얻을 수 있음
# 리액트 요소는 불변 객체이므로, 속성값을 변경할 수 없음
# 하나의 화면을 표현하기 위해 여러 개의 리액트 요소가 트리(tree) 구조로 구성됨
## 프로그램 화면은 여러가지 이벤트를 통해 다양한 모습으로 변화됨
## 하나의 리액트 요소 트리는 시간에 따러 변화하는 화면의 한 순간을 보여줌
# 리액트에서 데이터 변경에 의한 화면 업데이트는 렌더 단계(render phase, reconciliation phase)와 커밋 단계 (commit phase)를 거침
## 렌더는 실제 돔에 반영할 변경 사항을 파악하는 단계임
### 렌더 단계에서 변경 사항을 파악하기 위해 가상 돔을 이용함
### 가상 돔은 리액트 요소로부터 만들어지며, 렌더링을 할 떄마다 가상 돔을 만들고 이전의 가상 돔과 비교함 => 실제 돔의 변경 사항을 최소화할 수 있음
## 커밋은 파악된 변경 사항을 실제 돔에 반영하는 단계임
# 리액트 요소 트리가 실제 돔으로 만들어지기 위해선 모든 리액트 요소의 type 속성 값이 문자열이어야 함
## type 속성값이 문자열이어야만 HTML 태그로 변환할 수 있기 때문임
# 실제 돔을 만들 수 있는 리액트 요소 트리를 가상 돔이라고 함
## 최초의 리액트 요소 트리로부터 가상 돔을 만들고, 이전 가상 돔과 비교하여 실제 돔에 반영할 내용을 결정하는 단계를 렌더링이라고 함
## 리액트는 화면을 업데이트를 할 때 이전의 가상 돔과 현재의 가상 돔을 비교해서 변경된 부분만 실제 돔에 반영함
## 브라우저에서 실제 돔을 번경하는 작업은 다른 작업에 비해 시간이 오래 걸리므로, 꼭 필요한 부분만 변경하는 것이 중요함
## 최종 리액트 요소 트리를 만들기 위해 치환되는 컴포넌트의 리액트 요소도 메모리에 유지됨
### 메모리에 저장된 컴포넌트의 리액트 요소는 렌더 단계의 효율을 높이는 데 사용됨
### 가상 돔은 UI에서 변경된 부분을 빨리 찾기 위한 개념으로 컴포넌트의 리액트 요소도 가상 돔의 일부라고 생각할 수 있음
# 렌더 단계는 ReactDOM.render 함수와 상탯값 변경 함수에 의해 시작됨
# ReactDOM.render 함수 호출 -> 최초의 렌더 단계 실행 -> 가상 돔을 실제 돔으로 생성 -> [상태 값 변경] -> 두 번째 렌더 단계 실행 -> 새로운 가상 돔 생성 -> 이전 가상 돔과 비교 및 변경된 부분에 대한 실제 돔 반영됨
## 리액트 요소는 파이버(fiber)라는 구조체로 변환됨 -> 파이버는 리액트 버전 16부터 도입된 구조체 이름
### 파이버도 리액트 요소와 같이 type, props 속성 값을 가지며, 동작할 때에도 모든 type 속성 값이 문자열이 될 때까지 연산함
# 리액트 훅은 함수형 컴포넌트에 기능을 추가할 때 사용하는 함수임
## 훅을 이용하면 함수형 컴포넌트에서 상탯값을 사용할 수 있으며, 자식 요소에 접근도 가능함
## 훅은 비교적 최근에 추가된 기능으로 기존 리액트가 가지고 있는 여러 문제를 해결해줌
### 새로 작성하는 컴포넌트는 되도록 클래스형 컴포넌트보다는 훅을 사용하여 함수형 컴포넌트로 작성하는 것이 좋음
### 훅이 주는 장점이 좋고, 리액트 팀에서도 적극적으로 훅과 관련된 기능 개발에 노력하고 있음
# useState 훅을 이용하면 컴포넌트에 상탯값을 추가할 수 있음
## useState 훅이 반환하는 배열의 두 번째 원소는 상탯값 변경 함수임
### 리액트는 상탯값 변경 함수가 호출되면 해당 컴포넌트를 다시 그리며, 그 과정에서 자식 컴포넌트도 같이 렌더링됨
### 리액트는 가능하다면 상탯값 변경을 배치(batch)로 처리함
### 상탯값 변경 함수는 비동기로 동작함
#### 리액트가 상탯값 변경 함수를 동기로 처리하면 하나의 상탯값 변경 함수가 호출될 때마다 화면을 다시 그리기 때문에 성능 이슈가 발생될 수 있음
#### 동기로 처리하지만 매번 화면을 다시 그리지 않으면 UI 데이터와 화면 간의 불일치가 발생함
### 리액트는 효율적으로 렌더링하기 위해 여러 개의 상탯값 변경 요청을 배치로 처리함
### 상탯값 변경 함수의 인수가 함수인 경우, 입력된 함수는 자신이 호출되기 직전의 상탯값을 매개변수로 받음
### 상탯값 변경 함수는 비동기로 처리되나, 그 순서는 보장됨
### 상탯값 변경 함수는 클래스형 컴포넌트의 setState 메서드와 조금 다르게 동작함
#### setState 메서드는 기존 상탯값과 새로 입력된 값을 병합하지만, useState 훅의 상탯값 변경 함수는 이전 상탯값을 덮어씀
# 상탯값 변경이 배치로 처리되지 않는 경우
## 리액트는 내부에서 관리하는 이벤트 처리 함수에 대해서만 상탯값 변경을 배치로 처리함
## 리액트 외부에서 관리하는 이벤트 처리 함수의 경우, 상탯값 변경이 배치로 처리되지 않음
# useEffect 훅은 부수 효과를 처리하는 용도로 사용함
## 컴포넌트는 최초 렌더링 후, useEffect에 입력된 함수를 한 번만 호출함
# 리액트 외부에서 관리되는 이벤트 처리 함수에서도 원한다면 상탯값 변경을 배치로 처리할 수 있음
## unstable_batchedUpdates 함수를 이용하면 상탯값 변경 함수는 모두 배치로 처리됨
### 안정화된 API가 아니므로 꼭 필요한 경우가 아니라면 사용하지 않는 게 좋음
### 참고로 concurrent 모드로 동작할 미래의 리액트는 외부에서 관리되는 이벤트 처리 함수도 배치로 처리할 것으로 예상됨
# 함수 실행 시, 함수 외부의 상태를 변경하는 연산을 부수 효과라고 함
## 특별한 이유가 없다면 모든 부수 효과는 useEffect 훅에서 처리하는 게 좋음
## API를 호출하는 것과 이벤트 처리 함수를 등록하고, 해제하는 것이 부수 효과의 대표적인 예임
## useEffect 훅에 입력하는 함수를 부수 효과 함수라고 함
### 부수 효과 함수는 렌더링 결과가 실제 돔에 반영된 후 호출되고, 컴포넌트가 사라지기 직전에 마지막으로 호출됨
### 렌더링이 되고 끝날 때마다 부수 효과 함수가 호출됨
#### 부수 효과 함수는 렌더링 결과가 실제 돔에 반영된 후에 비동기로 호출함
# 부수 효과 함수는 렌더링이 될 때마다 실행되므로, 불필요한 호출이 많이 발생되므로 이를 방지하기 위해 useEffect 훅의 두 번째 매개변수로 배열을 입력하면, 배열의 값이 변경되는 경우에만 함수가 호출됨 => 이 배열을 의존성 배열이라고 함
## 의존성 배열로 빈 배열을 입력하면 컴포넌트가 생성될 때에만 부수 효과 함수가 호출되고, 컴포넌트가 사라질 때만 반환된 함수가 호출됨
## 대개의 경우, 의존성 배열을 입력할 필요가 없음 => useEffect 훅을 사용할 때 많은 버그가 의존성 배열을 잘못 입력하면서 발생됨
# 부수 효과 함수는 함수를 반환할 수 있으며, 반환된 함수는 호출되기 직전에 호출되고, 컴포넌트가 사라지기 직전에 마지막으로 호출됨
## 부수 효과 함수가 반환한 함수는 프로그램이 비정상적으로 종료되지 않는 한 반드시 호출됨
# 리액트가 제공하는 훅을 사용하면 커스텀 훅을 만들 수 있음
## 커스텀 훅을 이용해서 또 다른 커스텀 훅을 만들 수 있으며 직접 만들어서 사용하면 쉽게 로직을 재사용할 수 있다는 장점이 있음
## 리액트의 내장 훅처럼 커스텀 훅의 이름은 use로 시작하는 게 좋음 => 코드 가독성 증가,. 여러 리액트 개발 도구의 도움도 쉽게 받을 수 있음
## 레고 블록처럼 기존 훅을 이용하여 새로운 훅을 만들 수 있는 것은 좋음
## 커스텀 훅도 리액트에서 제공하는 내장 훅과 마찬가지로 단순히 함수를 호출하는 방식으로 간단하게 사용이 가능
# 리액트에서 마운트란 컴포넌트의 첫 번재 렌더링 결과가 실제 돔에 반영된 상태를 의미함
# 훅을 사용할 때에는 하기의 사항을 지켜야 함
## 하나의 컴포넌트에서 훅을 호출하는 순서는 항상 같아야 함
### 조건에 따라 훅을 호출하면 순서가 보장되지 않음
### 루프 안에서 훅을 호출하면 순서가 보장되지 않음
### 함수에서 훅을 호출하면 언제 호출될 지 몰라 순서가 보장되지 않음
## 훅은 함수형 컴포넌트 또는 커스텀 훅 안에서만 호출되어야만 함
### 위 두 가지를 지켜야만 리액트가 각 훅의 상태를 제대로 기억할 수 있음
## 훅은 클래스형 컴포넌트의 메서드 뿐만이 아닌 기타 일반 함수에서도 사용할 수 없음
### 이는 함수형 컴포넌트를 위한 기능이므로 당연한 경우임
# 리액트가 내부적으로 훅을 처리하는 방식은 하기와 같음
## 리액트가 내장하고 있는 훅 함수를 호출 -> 각 훅 함수에서 hooks 배열에 자신의 데이터를 추가 -> 렌더링 과정에서 하나의 컴포넌트를 처리 -> hooks를 빈 배열로 초기화ㅣ -> 컴포넌트 내부에서 훅을 사용한만큼 hooks 배열에 데이터를 추가 -> 생성된 배열을 저장한 후, hooks 변수를 초기화
### 리액트는 훅이 사용된 순서를 저장하고, 배열에 저장된 순서를 기반으로 훅을 관리함
# 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때 속성 값을 사용함
## 가까운 거리에 있는 몇 개의 하위 컴포넌트에 데이터를 전달할 때에는 속성 값으로 충분히 전달이 가능함
## 많은 수의 하위 컴포넌트로 전달할 때 속성 값을 내려주는 코드를 반복적으로 작성해야 하는 문제가 존재
## 하위 컴포넌트가 상위 컴포넌트에서 상당히 멀리 있다면 중간에 있는 컴포넌트에서 지속적으로 속성 값을 전달하는 코드를 작성해야 함
# 콘텍스트 API는 컴포넌트의 중첩 구조가 복잡한 상황에서도 비교적 쉽게 데이틀 전달하도록 만들 수 있음
## 콘텍스트 API를 사용하면 상위 컴포넌트에서 하위에 있는 모든 컴포넌트로 직접 데이터를 전달할 수 있음
### 이 때, 중간에 있는 컴포넌트의 존재는 몰라도 무관하므로 속성값을 반복하여 내려주는 문제가 없어짐
## createContext 함수를 통해 콘텍스트 객체 생성
### 함수의 구조는 React.createContext(defaultValue) => { Provider, Consumer }
### Provider 컴포넌트로 데이터를 전달, Consumer 컴포넌트로 데이터를 사용
#### Consumer 컴포넌트는 데이터를 찾기 위해 상위로 올라가면 가장 가까운 Provider 컴포넌트를 찾음
##### 최상위에 도달할 때까지 Provider 컴포넌트를 찾지 못하면 기본값이 사용됨
##### 기본 값으로 인해 Provider 컴포넌트가 없어도 되므로, 어렵지 않게 최하위 컴포넌트의 테스트 코드 작성이 가능함
# 최상위 컴포넌트의 속성값이 변경되면 하위의 모든 컴포넌트는 다시 렌더링됨
## 중간에 위치한 컴포넌트의 렌더링 여부에 상관 없이 하위 컴포넌트가 다시 렌더링됨
# 데이터의 종류별로 콘텍스트를 만들어서 사용하면 렌더링 성능상의 이점이 존재함
## 데이터를 변경하는 경우, 해당 Consumer 컴포넌트만 렌더링이 되기 때문임
# 하위 컴포넌트에서도 콘텍스트 데이터를 수정할 수 있으며, 리덕스에서 상태를 변경하는 디스패치(dispatch) 함수를 여러 컴포넌트에서 사용할 수 있는 것처럼 콘텍스트 데이터도 원하는 곳에서 변경이 가능함
# 콘텍스트 API를 사용 시, 콘텍스트 데이터가 변경되지 않은 상황에서 불필요한 렌더링이 발생하거나, Consumer 컴포넌트의 Provider 컴포넌트의 잘못된 위치 때문에 콘텍스트 데이터가 전달되지 않을 수 있음
## 콘텍스트 데이터로 객체를 사용할 때 주의하지 않으면 불필요한 렌더링이 발생될 수 있음
# 리액트로 작업하다 보면 돔 요소에 직접 접근해야 할 때가 있음
## 돔 요소에 포커스를 주거나 돔 요소의 크기나 스크롤 위치를 알고 싶은 경우
## ref 값을 이용하면 자식 요소에 직접 접근이 가능함
### 자식 요소는 컴포넌트일 수도 있고, 돔 요소일 수도 있음
# useRef 훅이 반환하는 ref 객체를 이용하여 자식 요소에 접근할 수 있음
## 접근하고자 하는 자식 요소의 ref 속성 값에 ref 객체를 입력함
## 해당 돔 요소 혹은 컴포넌트가 생성되면 ref 객체로 접근할 수 있음
## ref 객체의 current 속성을 이용하면 자식 요소에 접근할 수 있음
# 부수 효과 함수는 컴포넌트 렌더링 결과가 돔에 반영된 후에 호출되므로 해당 돔 요소는 이미 생성된 상태임
# 클래스형 컴포넌트에 ref 속성 값을 입력하면 ref.current는 해당 컴포넌트의 인스턴스를 가리킴
## ref.current로 해당 클래스의 메서드를 호출할 수 있음
# 함수형 컴포넌트는 인스턴스로 만들어지지 않으나 useImperativeHandle 훅을 사용하면 함수형 컴포넌트에서도 변수 혹은 함수를 외부로 노출할 수 있음
## 함수형 컴포넌트에 ref 속성값을 입력할 수 없지만, 다른 이름으로 ref 객체를 입력받아서 내부의 리액트 요소에 연결할 수 있음
# 컴포넌트의 재사용성을 높이기 위해 Button처럼 단순한 컴포넌트를 만들어서 사용하는 경우가 많음
## 작은 컴포넌트는 돔 요소와 밀접하게 연관되어 있어, ref 속성값을 손자 요소로 연결하는 게 자연스러움
### 일관성 있게 독자적인 이름의 속성 값보단 ref라는 이름을 사용하는 게 좋음
#### 컴포넌트에 ref 속성값을 사용하면 리액트가 내부적으로 처리하기 때문에 손자 요소에 연결할 수 없음
# ref 속성값에 함수를 입력하면 자식 요소가 생성되거나 제거되는 시점에 호출됨
## ref 속성 값으로 입력한 함수는 해당 요소가 제거되거나 생성될 때마다 호출됨
## 요소가 생성될 떄에는 해당 요소를 참조하는 변수가 넘어오고, 삭제될 떄는 null 값이 넘어옴
# 리액트는 ref 속성 값으로 새로운 함수가 들어오면 이전 함수에 null 인수를 넣어서 호출하고, 새로운 함수에는 요소의 참조값을 넣어 호출함
## 텍스트를 입력하면 컴포넌트가 렌더링되고, ref 속성값에 입력된 새로운 함수가 호출되면서 INITIAL_TEXT로 덮어쓰는 것임
# userCallback 훅의 메모이제이션 기능 덕분에 한번 생성된 함수를 계속 재사용할 수 있음
# 컴포넌트가 생성된 이후에도 ref 객체의 current 속성이 없을 수 있음
## 조건부 렌더링을 하는 경우에 컴포넌트가 생성된 이후라고하여도 ref 객체를 사용할 때에는 주의해야 함
### 조건부 렌더링이 사용되는 경우 ref 객체는 current 속성을 검사하는 코드가 필요함
# Consumer 컴포넌트 없이 콘텍스트 사용하기 : useContext
# useContext 훅을 이용하면 Consumer 컴포넌트를 사용하지 않고 부모 컴포넌트로부터 전달된 콘텍스트 데이터를 사용할 수 있음
# 콘텍스트 API를 사용한 경우에는 Consumer 컴포넌트 안쪽에서만 콘텍스트 데이터에 접근할 수 있다는 한계가 존재함
## Consumer 콘텍스트는 사용하면 JSX가 복잡해지는 단점이 있으나, useContext 훅은 사용하기 간편한 장점이 있음
# 렌더링과 무관한 값 저장 : useRef
# useRef 훅은 자식 요소에 접근하는 것 외에도 중요한 용도가 한 가지 더 존재함
## 컴포넌트 내부에서 생성되는 값 중에는 렌더링과 무관한 값이 존재함
## useRef를 사용하면 이 값을 저장하는 것이 가능함
## useState 훅도 변수로 사용될 수 있으나, 컴포넌트의 생명 주기와 밀접하게 연관되어 있어 렌더링과 무관한 값을 저장하기엔 적합하지 않음
# 메모이제이션 훅 : useMemo, useCallback
# useMemo와 useCallback은 이전 값을 기억하여 성능을 최적화하는 용도로 사용됨
## useMemo 훅은 계산량이 많은 함수의 반환 값을 재활용하는 용도로 사용됨
### useMemo 훅의 첫 번째 매개변수는 함수이며, userMemo 훅은 이 함수가 반환하는 값을 기억함
### useMemo 훅의 두 번째 매개변수는 의존성 배열임, 의존성 배열이 변경되지 않으면 이전에 반환된 값을 재사용함, 배열 값이 변경되면 첫 번째 매개변수로 입력된 함수를 실행하고, 그 반환 값을 기억함
### useMemo 훅은 lodash 같은 라이브러리에서 제공해주는 메모이제이션과 비슷함
## useCallback은 리액트의 렌더링 성능을 위해 제공되는 훅임
### 컴포넌트가 렌더링될 때마다 새로운 함수를 생성하여 자식 컴포넌트의 속성값으로 입력하는 경우가 많음
### 리액트 팀에선 최근의 브라우저에서 함수 생성이 성능에 미치는 영향이 작다고 얘기함
### 속성 값이 매번 변경되므로 자식 컴포넌트에서 React.memo를 사용해도 불필요한 렌더링이 발생하는 문제가 존재함
### useCallback 훅의 첫 번째 매개변수는 함수로 전달함
### useCallback 훅의 두 번째 매개변수는 의존성 배열로, 의존성 배열이 변경되지 않으면 이전에 생성한 함수가 재사용됨
# useReducer를 사용하면 컴포넌트의 상탯값을 리덕스의 리듀서처럼 관리하는 것이 가능함
## 리덕스의 리듀서와 동일한 방식의 함수를 작성
## useReducer 훅의 매개변수로 앞에서 작성한 리듀서와 초기 상탯값을 입력함
## useReducer 훅은 상탯값과 dispatch 함수를 차례대로 반환함
# 보통 상위 컴포넌트에서 다수의 상탯값을 관히하며, 자식 컴포넌트로부터 발생한 이벤트에서 상위 컴포넌트의 상탯값을 변경하는 경우가 많음
## 상위 컴포넌트에서 트리의 깊은 곳까지 이벤트 처리 함수를 전달함 => 이 작업은 손이 많이 가고, 코드의 가독성도 떨어짐
## useReducer 훅과 콘텍스트 API를 이용하면 상위 컴포넌트에서 트리의 깊은 곳으로 이벤트 처리 함수를 쉽게 전달할 수 있음
## useReducer 훅의 dispatch 함수는 값이 변하지 않는 특징이 있어 콘텍스트의 Consumer 컴포넌트가 불필요하게 자주 렌더링되는 일은 발생하지 않음
# 부모 컴포넌트에서 접근 가능한 함수 구현 : useImperativeHandle
## 부모 컴포넌트는 ref 객체를 통해 클래스형 컴포넌트인 자식 컴포넌트의 메서드를 호출할 수 있음
### 이 방식은 자식 컴포넌트의 내부 구현에 대한 의존성이 생기므로 지양해야 하나, 꼭 필요한 경우가 종종 발생됨
## useImperativeHandle 훅을 이용하면 마치 함수형 컴포넌트에도 메서드가 있는 것처럼 만드는 것이 가능함
### 부모 컴포넌트에서 입력한 ref 객체를 직접 처리하기 위해 forwardRef 함수를 호출함
### useImperativeHandle 훅으로 ref 객체와 부모 컴포넌트에서 접근 가능한 여러 함수를 입력함
# useLayoutEffect
## useEffect 훅에 입력된 부수 효과 함수는 렌더링 결과가 돔에 반영된 후 비동기로 호출됨
## useLayoutEffect 훅은 useEffect 훅과 거의 비슷하게 동작하나 부수 효과 함수를 동기로 호출하는 점이 다름
### useLayoutEffect 훅의 부수 효과 함수는 렌더링 결과가 돔에 반영된 직후에 호출됨
### useLayoutEffect 훅의 부수 효과 함수에서 연산을 많이 하면 브라우저가 먹통이 될 수 있어 주의해야 함
#### 특별한 이유가 없다면 useEffect 훅을 사용하는 것이 성능상 이점이 존재함
## 렌더링 직후 돔 요소의 값을 읽는 경우에는 useLayoutEffect 훅을 사용하는 것이 적합함
# useDebugValue
## useDebugValue는 개발 편의를 위해 제공되는 훅임
## useDebugValue 훅을 사용하면 커스텀 훅의 내부 상태를 관찰할 수 있어 디버깅에 도움이 됨
## useDebugValue 훅으로 입력한 값은 리액트 개발자 도구에서 확인할 수 있음