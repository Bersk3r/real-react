# useEffect 훅의 기능은 간단하지만, 그것을 제대로 사용하는 것은 어려움
## 개발자들은 훅이 등장하기 전 사용하던 클래스형 컴포넌트에 익숙해져 있어 잘못된 방법으로 접근하는 경우가 많음
## useEffect 훅을 잘못 사용하면 오래된 데이터를 참조하거나 부수 효과 함수가 자주 실행되는 문제가 발생할 수 있음
# 컴포넌트 코드를 작성할 떄 가독서오가 생산성을 높여주는 방법
## 같은 기능을 하는 컴포넌트라도 다양한 방식으로 작성될 수 있음
## 되도록 컴포넌트를 작성하는 사람 입장에서는 유지 보수하기 쉬운 코드를, 컴포넌트를 사용하는 입장에서는 컴포넌트의 인터페이스를 쉽게 파악할 수 있음
# 추천하는 컴포넌트 파일 작성법
## 컴포넌트 파일에는 다양한 종류의 함수와 변수가 나타남
## 그로 인해 코드의 가독성이 떨어지고, 관리가 힘들어질 수 있음
# 컴포넌트 파일 작성 순서
## 파일의 최상단에 컴포넌트의 속성값 타입을 정의
### 컴포넌트를 사용하는 입장에서 생각하면 쉽게 이해됨
### 컴포넌트를 사용하기 위해, 그 컴포넌트의 속성값 타입을 알아야하므로, 파일을 열었을 떄 속성값 타입이 가장 먼저 보이는 게 좋음
### 속성값 타입 위쪽으로는 import 코드만 오도록 작성할 것
## 컴포넌트 함수의 매개변수는 명명된 매개변수로 정의하는 게 좋음
### 속성값을 사용할 때마다, props.을 반복하여 입력하지 않아도 되므로 코드 작성이 편해짐
### function()처럼 이름 없는 컴포넌트로 만들면 리액트 개발자 도구에서 디버깅이 어려움
## 컴포넌트 바깥의 변수와 함수는 파일의 가장 밑에 정의할 것
### 특별한 이유가 없다면 변수는 상수변수(const)로 정의하는 게 좋음
### 상수 변수의 이름은 예제처럼 대문자로 작성하는 게 가독성에 좋음
### 컴포넌트 내부에서 커다란 객체를 생성하는 코드가 있을 때, 가능하다면 컴포넌트 외부에서 상수 변수로 정의해서 사용하는 것이 좋음
### 렌더링 시 불필요한 객체 생성을 피할 수 있어서 성능상 이점이 존재함
# 서로 연관된 코드를 한 곳으로 모으기
## 모든 상탯값을 컴포넌트 함수 상단에서 정의하고 있음
## 모든 useEffect 훅을 상탯값 코드 밑에 정의하고 있음
## 코드를 한 곳으로 모을때는 훅의 종류별로 모으는 것보다는 연관된 코드끼리 모으는 게 좋음
## 컴포넌트 코드가 복잡하다고 느껴지면 각 기능을 커스텀 훅으로 분리하는 것도 좋음
### 기능을 커스텀 훅으로 분리하면 같ㅇ든 기능을 다른 곳에서도 사용하기 좋음
### 기능을 재사용하는 곳이 없어도 컴포넌트 코드가 복잡해지면 커스텀 훅으로 분리하자
### 다만 컴포넌트 코드가 복잡하지 않은 경우 커스텀 훅이 오히려 가독성을 떨어뜨릴 수 있으므로 필요하다고 생각할 때 쓸 것
# 속성 값 타입 정의하기: prop-types
## prop-types는 속성값의 타입 정보를 정의할 때 사용하는 리액트 공식 패키지임
## 속성값의 타입 정보는 컴포넌트 코드의 가독성을 위해서 필수로 작성하는 게 좋음
## 자바스크립트는 동적 타입 언어로 타입이 없으므로 배우기 쉽고 간단한 규모의 프로그램을 작성할 때는 생산성이 좋음
### 하지만 소스 파일이 50개가 넘어가는 규모의 프로그램을 작성할 때는 생산성이 떨어짐
### 가능하면 정적 타입 언어를 사용하는 게 좋으나, 상황에 따라 동적 타입 언어를 사용해야 하는 경우가 있음
#### 이 때, prop-types를 사용하면 컴포넌트 사용 시 속성값에 잘못된 타입이 입력되면 콘솔에 에러 메세지를 출력함
#### 이는 리액트가 렌더링하는 과정에서 잘못된 속성값 타입을 검사해주므로 가능함
##### 속성값 타입을 검사하기 위한 별도의 연산이 필요하므로 타입 검사는 개발 모드에서만 동작함
##### 타입 에러를 사전에 검사할 수 있어 도움이 됨
## prop-types를 사용했을 때 생기는 또 다른 장점은 타입 정의 자체가 훌륭한 문서가 된다는 점임
### 속성값 타입 정보가 없으면 컴포넌트를 사용하는 사람 입장에선 속성값의 정보를 파악하기 위해 코드를 일일이 봐야함
#### prop-types를 사용하면 컴포넌트의 로직을 이해하지 않고도 속성값의 타입 정보를 한눈에 알 수 있음
### 함수 타입은 prop-types에서 함수의 매개변수와 반환 값에 대한 타입 정보는 정의할 수 없음
## prop-types가 제공하는 타입 정의 함수를 이용하면 왠만한 타입 정보는 표현할 수 있음
# 컴포넌트 함수 내부에서 특정 값에 따라 선택적으로 렌더링하는 것을 조건부 렌더링(conditional rendering)이라 함
## 조건부 렌더링을 구현할 떄는 삼항 연산자가 유용한 경우도 있으나, 대부분 && 연산자가 가독성이 더 좋음
# 조건부 렌더링을 무분별하게 사용하면 JSX 코드는 금방 스파게티가 되므로, 더 좋은 코드에 대한 고민을 많이 하는 것이 좋음
## JSX 코드에서는 삼항 연산자보다 && 연산자를 사용한 조건부 렌더링 코드가 더 가독성이 높음
### 코드의 끝에 null을 생략해도 되므로 가독성이 좋아짐
# &&, || 연산자 이해하기
## &&, || 연산자 모두 마지막으로 검사한 값을 반환
## && 연산자는 첫 거짓(false) 값 또는 마지막 값을 반환하고, || 연산자는 첫 참(true)값 또는 마지막 값을 반환함
## 따라서 렌더링할 리액트 요소를 && 연산자를 끝에 작성하고, 앞쪽에는 해당 조건을 작성하는 방식으로 조건부 렌더링을 구현가능함
# && 연산자를 사용 시 주의할 점
## 변수가 숫자 타입인 경우 0은 거짓이고, 문자열 타입인 경우 빈 문자열도 거짓임
# 변수가 빈 배열인 경우에는 기본 값으로 빈 배열을 넣어주는 게 좋음
## 기본 값이 빈 배열이면 조건부 렌더링을 할 때마다 편하게 map 함수 사용이 가능함
# 조건에 따라 아무 것도 렌더링하지 않는 경우에는 null을 반환함
## 해당 컴포넌트를 사용하는 부모 컴포넌트에서 조건에 따라 자식 컴포넌트를 보이거나 가릴 수도 있음
### 해당 경우는 해당 컴포넌트가 마운트와 언마운트를 반복할 수 있다는 인지해야 함
### 마운트와 언마운트를 반복하면 컴포넌트의 상탯값도 사라지고 렌더링 서능에도 안 좋은 영향을 줄 수 있음
## 필요한 조건을 부모 컴포넌트에서 작성하므로 자식 컴포넌트의 입장에선 로직이 더 간단해진다는 장점도 존재함
# 조건부 렌더링의 방법은 다양하므로 각자의 취향과 프로젝트의 성격에 따라 코딩 컨벤션을 정하는 게 좋음
## 코드 리뷰 시에는 조건부 렌더링 쪽 코드가 복잡해서 힘들어지는 경우도 있어, 조건부 렌더링 코드를 수정할 떄는 리뷰어를 배려하는 마음으로 코드를 작성할 것
# 관심사 분리를 위한 프레젠테이션 컨테이너 컴포넌트 구분하기
## 댄 아브라모프의 블로그 포스트 중 잘 알려진 컴포넌트 구분법이 있음
### 비즈니스 로직과 상탯값의 유무에 따라 프레젠테이션(Presentation)과 컨테이너(Container)로 불리는 두 가지 컴포넌트로 구분함
# 프로그래밍의 세계에서 관심사의 분리란 복잡한 코드를 비슷한 기능을 하는 코드끼리 모아서 별도로 관리하는 것을 얘기함
# UI 처리, API 호출, DB 관리 등의 코드가 같은 곳에 있으면 복잡하므로 이들은 서로의 관심사가 다르다고 판단하여 분리해서 관리하는 게 좋음
# 코드를 작성하다가 어느 순간 코드가 복잡해진다고 느껴지만 관심사의 분리가 필요한 순간인지 생각해보는 게 좋음
## 하나의 컴포넌트 안에서 모든 기능을 구현할 수 없으므로, 여러 개의 컴포넌트를 만들어 조립함
## 하나의 폴더 안에 모든 컴포넌트를 모아 놓고 가정하면 시간이 흐를수록 컴포넌트의 갯수는 많아지고 사용하려는 컴포넌트 탐색이 어려워짐
## 이 때 기능별로 폴더를 만들어 관리하면 컴포넌트 찾기가 쉬워지고 간단한 프로그램은 이 정도로 충분함
### 프로젝트 규모가 커졌을 때 문제가 발생하는 데 비즈니스 로직과 상탯값이 컴포넌트 여기저기에 흩어져 있어, 상탯값 중복도 발생함
#### 특정 목록의 이름을 수정하는 순간, 부모가 가진 데이터와 정합(sync)가 맞지 않아 버그가 발생함
### 자식 컴포넌트에서 부모의 데이터를 별도의 상탯값으로 관리하는 것은 나쁜 습관 (anti-pattern)이며 비즈니스 로직과 상탯값은 일부 컴포넌트로 한정해서 관리하는 게 좋음
#### 컴포넌트가 비즈니스 로직이나 상탯값을 가지고 있으면 재사용이 어려움
##### 컴포넌트는 재사용할수록 좋으나 컴포넌트에 비즈니스 로직이나 상탯값이 있어서 재사용을 못 하고 새로운 컴포넌트를 만들면 코드 중복이 발생될 수 있음
##### 개발자에게 코드 중복은 게이름이며 기술 부채이다.
# 속성값으로부터 상탯값을 만드는 것이 나쁜 습관이라고 말하는 게 아님, 리액트의 getDerivedStateFromProps 생명 주기 메서드가 정확히 이 기능을 위해 존재함
## 데이터를 복제하는 순간 나쁜 습관이 됨
## 속성값을 변경하는 순간, 새로운 객체가 생성되어 더 이상 부모 객체를 참조하지 않게 됨 => 상탯값을 불변 객체로 관리하기 때문
# 프레젠테이션 컴포넌트의 정의
## 비즈니스 로직이 없음
## 상탯값이 없음. 단 마우스 오버(mouse over)와 같은 UI 효과를 위한 상탯값은 제외함
### 컴포넌트를 프레젠테이션과 컨테이너로 구분하고 폴더도 이에 따라 별도로 관리하는 게 좋음
#### 프레젠테이션 컴포넌트 코드가 일반적으로 가독성이 더 좋고, 재사용성도 높음