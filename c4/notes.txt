# useEffect 훅의 기능은 간단하지만, 그것을 제대로 사용하는 것은 어려움
## 개발자들은 훅이 등장하기 전 사용하던 클래스형 컴포넌트에 익숙해져 있어 잘못된 방법으로 접근하는 경우가 많음
## useEffect 훅을 잘못 사용하면 오래된 데이터를 참조하거나 부수 효과 함수가 자주 실행되는 문제가 발생할 수 있음
# 컴포넌트 코드를 작성할 떄 가독서오가 생산성을 높여주는 방법
## 같은 기능을 하는 컴포넌트라도 다양한 방식으로 작성될 수 있음
## 되도록 컴포넌트를 작성하는 사람 입장에서는 유지 보수하기 쉬운 코드를, 컴포넌트를 사용하는 입장에서는 컴포넌트의 인터페이스를 쉽게 파악할 수 있음
# 추천하는 컴포넌트 파일 작성법
## 컴포넌트 파일에는 다양한 종류의 함수와 변수가 나타남
## 그로 인해 코드의 가독성이 떨어지고, 관리가 힘들어질 수 있음
# 컴포넌트 파일 작성 순서
## 파일의 최상단에 컴포넌트의 속성값 타입을 정의
### 컴포넌트를 사용하는 입장에서 생각하면 쉽게 이해됨
### 컴포넌트를 사용하기 위해, 그 컴포넌트의 속성값 타입을 알아야하므로, 파일을 열었을 떄 속성값 타입이 가장 먼저 보이는 게 좋음
### 속성값 타입 위쪽으로는 import 코드만 오도록 작성할 것
## 컴포넌트 함수의 매개변수는 명명된 매개변수로 정의하는 게 좋음
### 속성값을 사용할 때마다, props.을 반복하여 입력하지 않아도 되므로 코드 작성이 편해짐
### function()처럼 이름 없는 컴포넌트로 만들면 리액트 개발자 도구에서 디버깅이 어려움
## 컴포넌트 바깥의 변수와 함수는 파일의 가장 밑에 정의할 것
### 특별한 이유가 없다면 변수는 상수변수(const)로 정의하는 게 좋음
### 상수 변수의 이름은 예제처럼 대문자로 작성하는 게 가독성에 좋음
### 컴포넌트 내부에서 커다란 객체를 생성하는 코드가 있을 때, 가능하다면 컴포넌트 외부에서 상수 변수로 정의해서 사용하는 것이 좋음
### 렌더링 시 불필요한 객체 생성을 피할 수 있어서 성능상 이점이 존재함
# 서로 연관된 코드를 한 곳으로 모으기
## 모든 상탯값을 컴포넌트 함수 상단에서 정의하고 있음
## 모든 useEffect 훅을 상탯값 코드 밑에 정의하고 있음
## 코드를 한 곳으로 모을때는 훅의 종류별로 모으는 것보다는 연관된 코드끼리 모으는 게 좋음
## 컴포넌트 코드가 복잡하다고 느껴지면 각 기능을 커스텀 훅으로 분리하는 것도 좋음
### 기능을 커스텀 훅으로 분리하면 같ㅇ든 기능을 다른 곳에서도 사용하기 좋음
### 기능을 재사용하는 곳이 없어도 컴포넌트 코드가 복잡해지면 커스텀 훅으로 분리하자
### 다만 컴포넌트 코드가 복잡하지 않은 경우 커스텀 훅이 오히려 가독성을 떨어뜨릴 수 있으므로 필요하다고 생각할 때 쓸 것
# 속성 값 타입 정의하기: prop-types
## prop-types는 속성값의 타입 정보를 정의할 때 사용하는 리액트 공식 패키지임
## 속성값의 타입 정보는 컴포넌트 코드의 가독성을 위해서 필수로 작성하는 게 좋음
## 자바스크립트는 동적 타입 언어로 타입이 없으므로 배우기 쉽고 간단한 규모의 프로그램을 작성할 때는 생산성이 좋음
### 하지만 소스 파일이 50개가 넘어가는 규모의 프로그램을 작성할 때는 생산성이 떨어짐
### 가능하면 정적 타입 언어를 사용하는 게 좋으나, 상황에 따라 동적 타입 언어를 사용해야 하는 경우가 있음
#### 이 때, prop-types를 사용하면 컴포넌트 사용 시 속성값에 잘못된 타입이 입력되면 콘솔에 에러 메세지를 출력함
#### 이는 리액트가 렌더링하는 과정에서 잘못된 속성값 타입을 검사해주므로 가능함
##### 속성값 타입을 검사하기 위한 별도의 연산이 필요하므로 타입 검사는 개발 모드에서만 동작함
##### 타입 에러를 사전에 검사할 수 있어 도움이 됨
## prop-types를 사용했을 때 생기는 또 다른 장점은 타입 정의 자체가 훌륭한 문서가 된다는 점임
### 속성값 타입 정보가 없으면 컴포넌트를 사용하는 사람 입장에선 속성값의 정보를 파악하기 위해 코드를 일일이 봐야함
#### prop-types를 사용하면 컴포넌트의 로직을 이해하지 않고도 속성값의 타입 정보를 한눈에 알 수 있음
### 함수 타입은 prop-types에서 함수의 매개변수와 반환 값에 대한 타입 정보는 정의할 수 없음
## prop-types가 제공하는 타입 정의 함수를 이용하면 왠만한 타입 정보는 표현할 수 있음
# 컴포넌트 함수 내부에서 특정 값에 따라 선택적으로 렌더링하는 것을 조건부 렌더링(conditional rendering)이라 함
## 조건부 렌더링을 구현할 떄는 삼항 연산자가 유용한 경우도 있으나, 대부분 && 연산자가 가독성이 더 좋음
# 조건부 렌더링을 무분별하게 사용하면 JSX 코드는 금방 스파게티가 되므로, 더 좋은 코드에 대한 고민을 많이 하는 것이 좋음
## JSX 코드에서는 삼항 연산자보다 && 연산자를 사용한 조건부 렌더링 코드가 더 가독성이 높음
### 코드의 끝에 null을 생략해도 되므로 가독성이 좋아짐
# &&, || 연산자 이해하기
## &&, || 연산자 모두 마지막으로 검사한 값을 반환
## && 연산자는 첫 거짓(false) 값 또는 마지막 값을 반환하고, || 연산자는 첫 참(true)값 또는 마지막 값을 반환함
## 따라서 렌더링할 리액트 요소를 && 연산자를 끝에 작성하고, 앞쪽에는 해당 조건을 작성하는 방식으로 조건부 렌더링을 구현가능함
# && 연산자를 사용 시 주의할 점
## 변수가 숫자 타입인 경우 0은 거짓이고, 문자열 타입인 경우 빈 문자열도 거짓임
# 변수가 빈 배열인 경우에는 기본 값으로 빈 배열을 넣어주는 게 좋음
## 기본 값이 빈 배열이면 조건부 렌더링을 할 때마다 편하게 map 함수 사용이 가능함
# 조건에 따라 아무 것도 렌더링하지 않는 경우에는 null을 반환함
## 해당 컴포넌트를 사용하는 부모 컴포넌트에서 조건에 따라 자식 컴포넌트를 보이거나 가릴 수도 있음
### 해당 경우는 해당 컴포넌트가 마운트와 언마운트를 반복할 수 있다는 인지해야 함
### 마운트와 언마운트를 반복하면 컴포넌트의 상탯값도 사라지고 렌더링 서능에도 안 좋은 영향을 줄 수 있음
## 필요한 조건을 부모 컴포넌트에서 작성하므로 자식 컴포넌트의 입장에선 로직이 더 간단해진다는 장점도 존재함
# 조건부 렌더링의 방법은 다양하므로 각자의 취향과 프로젝트의 성격에 따라 코딩 컨벤션을 정하는 게 좋음
## 코드 리뷰 시에는 조건부 렌더링 쪽 코드가 복잡해서 힘들어지는 경우도 있어, 조건부 렌더링 코드를 수정할 떄는 리뷰어를 배려하는 마음으로 코드를 작성할 것
# 관심사 분리를 위한 프레젠테이션 컨테이너 컴포넌트 구분하기
## 댄 아브라모프의 블로그 포스트 중 잘 알려진 컴포넌트 구분법이 있음
### 비즈니스 로직과 상탯값의 유무에 따라 프레젠테이션(Presentation)과 컨테이너(Container)로 불리는 두 가지 컴포넌트로 구분함
# 프로그래밍의 세계에서 관심사의 분리란 복잡한 코드를 비슷한 기능을 하는 코드끼리 모아서 별도로 관리하는 것을 얘기함
# UI 처리, API 호출, DB 관리 등의 코드가 같은 곳에 있으면 복잡하므로 이들은 서로의 관심사가 다르다고 판단하여 분리해서 관리하는 게 좋음
# 코드를 작성하다가 어느 순간 코드가 복잡해진다고 느껴지만 관심사의 분리가 필요한 순간인지 생각해보는 게 좋음
## 하나의 컴포넌트 안에서 모든 기능을 구현할 수 없으므로, 여러 개의 컴포넌트를 만들어 조립함
## 하나의 폴더 안에 모든 컴포넌트를 모아 놓고 가정하면 시간이 흐를수록 컴포넌트의 갯수는 많아지고 사용하려는 컴포넌트 탐색이 어려워짐
## 이 때 기능별로 폴더를 만들어 관리하면 컴포넌트 찾기가 쉬워지고 간단한 프로그램은 이 정도로 충분함
### 프로젝트 규모가 커졌을 때 문제가 발생하는 데 비즈니스 로직과 상탯값이 컴포넌트 여기저기에 흩어져 있어, 상탯값 중복도 발생함
#### 특정 목록의 이름을 수정하는 순간, 부모가 가진 데이터와 정합(sync)가 맞지 않아 버그가 발생함
### 자식 컴포넌트에서 부모의 데이터를 별도의 상탯값으로 관리하는 것은 나쁜 습관 (anti-pattern)이며 비즈니스 로직과 상탯값은 일부 컴포넌트로 한정해서 관리하는 게 좋음
#### 컴포넌트가 비즈니스 로직이나 상탯값을 가지고 있으면 재사용이 어려움
##### 컴포넌트는 재사용할수록 좋으나 컴포넌트에 비즈니스 로직이나 상탯값이 있어서 재사용을 못 하고 새로운 컴포넌트를 만들면 코드 중복이 발생될 수 있음
##### 개발자에게 코드 중복은 게이름이며 기술 부채이다.
# 속성값으로부터 상탯값을 만드는 것이 나쁜 습관이라고 말하는 게 아님, 리액트의 getDerivedStateFromProps 생명 주기 메서드가 정확히 이 기능을 위해 존재함
## 데이터를 복제하는 순간 나쁜 습관이 됨
## 속성값을 변경하는 순간, 새로운 객체가 생성되어 더 이상 부모 객체를 참조하지 않게 됨 => 상탯값을 불변 객체로 관리하기 때문
# 프레젠테이션 컴포넌트의 정의
## 비즈니스 로직이 없음
## 상탯값이 없음. 단 마우스 오버(mouse over)와 같은 UI 효과를 위한 상탯값은 제외함
### 컴포넌트를 프레젠테이션과 컨테이너로 구분하고 폴더도 이에 따라 별도로 관리하는 게 좋음
#### 프레젠테이션 컴포넌트 코드가 일반적으로 가독성이 더 좋고, 재사용성도 높음
# useEffect 훅 실전 활용법
## 의존성 배열을 관하지 못해서 발생한 버그는 디버깅이 어려우므로, 제대로 이해해야 함
## 의존성 배열은 useEffect 훅에 입력하는 두 번째 매개변수임
### 가능하면 입력하지 않는 게 좋음
### 다행히 의존성 배열은 대부분 입력하지 않아도 됨 => 단, 입력이 필요한 경우가 있음
# useEffect에서 의존성 배열이 입력이 필요한 경우
## 부수 효과 함수에서 API를 호출하는 경우
### 부수 효과 함수에서 API를 호출한다면 불필요한 API 호출이 발생하지 않도록 주의해야 함
### 나중에 부수 효과 함수를 수정할 떄는 새로 추가된 변수를 빠짐 없이 의존성 배열에 추가해야 함
# 리액트 팀에서 부수 효과 함수에 변수 추가 누락을 막기 위해 eslint에서 사용할 수 있는 exhaustive-deps 규칙을 만들어 제공함
## exhaustive-deps는 잘못 사용된 의존성 배열을 찾아서 알려주며, 의존성 배열에서 실수를 하는 경우가 많고, 의존성 배열 떄문에 발생한 벅는 원이 파악이 힘드므로, exhaustive-deps를 사용하는 것을 추천함
# 의존성 배열을 잘못 관리하면, 의존성 배열에 입력해야 할 값을 입력하지 않으면 오래된 값을 참조하는 문제가 생김
## 컴포넌트 함수가 실행할 때마다, 부수 효과 함수가 생성되고, 함수는 생성될 당시의 변수를 참조함
## 같이 변수라고 하더라도, 부수 효과 함수가 생성되고, 함수는 생성될 당시의 변수를 참조함
### 즉, 부수 효과 함수는 함수가 생성된 시점의 예전 값을 참조하므로 예전에 생성된 부수 효과 함수는 예전 값을 참조함
# useEffect 훅에서 async/await 함수 사용
## useEffect 훅에서 async/await 함수를 사용하기 위해 부수 효과 함수를 async/await로 바꾸면 에러가 발생함
### 부수 효과 함수의 반환 값은 항상 함수 타입여야 되기 때문임
#### async/await 함수는 프로미스 객체를 반환하므로 부수 효과 함수가 될 수 없음
### 부수 효과 함수는 함수만 반환이 가능하며, 반환된 함수는 부수 효과 함수가 호출되기 직전과 컴포넌트가 사라지기 직전에 호출됨
## userEffect 훅에서 async/await 사용 방법은 부수 효과 함수 내에서 async/await 함수를 만들어서 호출하는 것
### 훅 내부에서 프로미스 기반의 함수를 사용하는 경우, 해당 함수를 의존성 배열에 추가하는 것이 가능함
# 의존성 배열을 없애는 방법
## 가능한 한, 의존성 배열을 사용하지 않는 게 좋음
### 의존성 배열을 관리하는데 생각보다 많은 시간과 노력이 발생되기 때문임
### 속성 값으로 전달되는 함수를 의존성 배열에 넣는 순간, 그 함수는 useCallback 등을 사용해서 자주 변경되지 않도록 신경써서 관리해야 함
## 의존성 배열을 입력하지 않는 대신 부수 효과 함수 내에서 실행 시점을 조절할 수 있음
### 의존성 배열을 입력하지 않으면 부수 효과 함수에서 사용된 모든 변수는 가상 최신화된 값을 참조하므로 안심해도 됨
## useState의 상탯값 변경 함수에 함수 입력
### 이전 상탯값을 기반으로 다음 상탯값을 계산하기 위해 상탯값을 의존성 배열에 넣는 경우가 존재함
#### 상탯값 변경 함수에 함수를 입력하면 이전 상탯값을 매개변수로 받을 수 있어 의존성 배열에서 제거할 수 있음
## useReducer 활용
### 여러 상탯값을 참조하면서 값을 변경할 때는 useReducer 훅을 사용하는 게 좋음
#### 타이머에서 시간이 흐르면, 시, 분, 초라는 세 가지 상탯값을 참조하여 값을 변경함
### 여러 상탯값을 참조해야 하는 경우, useReducer 훅을 사용하면 의존성 배열에서 쉽게 제거할 수 있음
#### useReducer를 사용하면 다양한 액션과 상탯값으 관리하기 용이하고, 상탯값 변경 로직을 여러 곳에서 재사용하기에도 좋음
## useRef 활용
### 의존성 배열이 자주 변경되는 문제를 해결하는 방법은 상황에 따라 없을 수도 있음
### 특히 속성 값으로 전달되는 함수는 자주 변경되는 경우가 많아, 해당 속성값이 렌더링 결과에 영향을 주는 값이 아니라면, useRef 훅을 이용하여 의존성 배열을 제거할 수 있음
### 속성값으로 전달된 함수 내용은 그대로인데, 렌더링할 때마다 변경되는 경우가 많음, 이로 인한 부수 효과 함수가 불필요하게 호출됨
#### 이런 경우, useRef 훅이 손쉬운 해결할 수 있음
##### 이 때, useRef에는 렌더링 결과와 무관한 값을 저장해야 함 => useRef에 저장된 값이 변경되어도 컴포넌트가 다시 렌더링되지 않기 때문임
### useRef 값을 부수 효과 함수에서 변경하는 이유
#### 부수 효과 함수에서 값을 수정하는 겂보다 빠른 시점에 수정함
#### useEffect 코드를 작성하는 것보다 간편함
#### 부수 효과 함수에서 useRef 값을 수정하는 이유는 나중에 도일될 리액트의 concurrent 모드 때문임
##### concurrent 모드로 동작할 때는 컴포넌트 함수가 실행됐다고 해도 중간에 렌더링이 취소될 수 있음
##### 렌더링은 취소되었는데, useRef에서 잘못된 값이 저장될 수 있으므로 useRef 값은 컴포넌트 함수에서 직접 수정하면 안 됨
##### 단, concurrent 모드로 동작하지 않는 리액트 버전에선 문제가 되지 않음
# 렌더링 속도를 올리기 위한 성능 최적화 방법
## 리액트가 실행될 때, 가장 많은 CPU 리소스를 차지하는 것은 렌더링임
### 리액트는 UI 라이브러리이기 때문에 프로그램이 실행되는 동안에 홤녀을 그리고 또 그림
### 리액트는 데이터와 컴포넌트 함수로 화면을 그림
### 그 과정에서 대부분의 연산은 컴포넌트 함수의 실행과 가상돔에서 발생함
#### 여기서 데이터는 컴포넌트의 속성값과 상탯값을 의미함
### 속성값이나 상탯값이 변경되면 리액트는 자동으로 컴포넌트 함수를 이용하여 화면을 다시 그림 => 리액트의 역할
> 리액트에서 최초 렌더링 이후에는 데이터 변경 시 렌더링을 하는 데, 이 때 다음과 같은 단계로 진행됨
>> 이전 렌더링 결과를 재사용할지 판단함 -> 컴포넌트 함수를 호출함 -> 가상 돔끼리 비교하여, 변경된 부분만 실제 돔에 반영함
>>> 첫 번째 단계에서 속성값이나 상탯값의 이전/이후 값을 비교하고, 이후 단계를 생략할 수 있음
>>> 클래스형 컴포넌트에선 shouldComponentUpdate 메서드가 그리는 역할을 하고, 함수형 컴포넌트에선 React.memo를 이용하여 구현할 수 있음
>>> 첫 번째 단계에서 렌더링이 필요하다고 판단되면 컴포넌트 함수를 호출함
>>> 컴포넌트 함수를 호출하여 새로운 가상 돔을 만들고, 이전에 만들었던 가상 돔과 비교하여 변경점을 찾음
>>> 변경된 부분은 실제 돔에 반영함
# React.memo로 렌더링 결과 재사용하기
## 컴포넌트의 속성값이나 상탯값이 변경되면 리액트는 그 컴포넌트를 다시 그릴 준비를 함
### 만약 React.memo 함수로 감싼 컴포넌트라면 속성값 비교 함수가 호출됨
### 이 함수는 이전/이후 속성값을 매개변수로 받아서 참/거짓을 반환함
#### 참을 반환하면 렌더링을 멈추고, 거짓을 반환하면 컴포넌트 함수를 실행하여 가상 돔을 업데이트한 후, 변경된 부분만 실제 돔에 반영함
### 컴포넌트를 React.memo 함수로 감싸지 않으면 항상 거짓을 반홚하는 속성값 비교 함수가 사용된다고 생각할 수 있음
#### 속성 값이 변경되지 않아도 부모 컴포넌트가 렌더링될 때마다 컴포넌트도 렌더링됨
### 속성 값 비교 함수가 항상 거짓을 반환해도 속성값이 변경되지 않으면 실제 돔도 변경되지 않으므로, 대부분 문제가 되지 않음
#### 렌더링 성능이 중요한 상황에서는 컴포넌트를 React.memo 함수로 감싸서 컴포넌트 함수의 실행과 가상 돔의 계산을 생략할 수 있음
## React.memo에서 두 번째 매개변수로 속성값 비교 함수를 입력함
### 속성값 비교 함수에서 참을 반환하면 이후 단계를 생략하고, 이전 렌더링 결과를 재사용함
### 만약, 속성값 비교 함수를 입력하지 않으면 얕은 비교를 수행하는 기본 함수가 사용됨
## 속성 값을 불변 객체로 관리했다면 이전 이후의 값의 단순 비교만으로 컴포넌트의 속성값의 변경 여부를 알 수 있음
### 속성 값을 불변 객체로 관리하면 렌더링 성능에 큰 도움이 됨
## 리액트에서 속성 값의 변경 여부를 계산하는 알고리즘
### React.memo 함수로 컴포넌트를 만들면 속성값이 변경된 경우에만 렌더링을 함
#### React.memo 함수의 두 번째 매개변수인 속성값 비교 함수를 입력하지 않으면 리액트에서 기본으로 제공하는 함수가 사용됨
### 객체를 수정 불가능하게 관리하면 다음처럼 최상위 객체의 참조값만 비교하면 값의 변경 유무를 알 수 있음 (prevObj === nextObj)
### 리액트는 속성값의 변경 여부를 판단하기 위해 속성값에 직접 연결된 모든 속성을 비교함 (prevProps.prop1 === nextProps.prop1 && prevProps.prop2 === nextProps.prop2 && ...)
#### 위 내용에서 최상위 객체의 참조값만 비교하지 않고 이렇게 하는 이유는 JSX 문법이 createElement로 변경된 코드를 보면 알 수 있음
##### createElement로 변경된 코드를 보면 렌더링할 때마다 새로운 속성값 객체가 생성됨
#### 객체의 내부 속성값이 변경되지 않아도 최상위 객체의 참조값은 항상 변경됨
##### 따라서 리액트는 속성값의 최상위 객체에 직접 연결(1-depth)된 모든 값을 단순 비교함, 이를 얕은 비교(shallow compare)라고 함
# 함수의 값이 변하지 않도록 관리하기
## 컴포넌트 함수 내부에서 함수를 정의해서 자식 컴포넌트의 속성값으로 입력하면 함수의 내용이 변경되지 않아도 자식 컴포넌트 입장에서는 속성값이 변경되었다고 인식함
### onChange 속성값은 부모 컴포넌트가 렌더링될 때마다 새로운 함수로 만들어짐 -> useState나 useReducer의 상탯값 변경 함수는 변하지 않는다는 점을 이용하면 해결 가능
### 이벤트 처리 함수에서 상탯값 변경 외에도 다른 처리가 필요하면 useCallback을 사용할 수 있음
#### 의존성 배열을 빈 배열로 입력하면 해당 함수는 항상 고정된 값을 가지게 됨
## 객체 값이 변하지 않도록 관리하기
### 함수와 마찬가지로 컴포넌트 내부에서 객체를 정의해서 자식 컴포넌트의 속성값으로 입력하면 자식 컴포넌트는 객체의 내용이 변경되지 않았음에도 속성값이 변경되었다고 인식함
### 이는 렌더링과 무관한 같은 값을 가지므로 컴포넌트 밖의 상수로 관리하면 됨
### 다른 상탯값이나 속성값을 이용하여 계산되는 값은 상수 변수로 관리할 수 없음
## useMemo 훅을 이용하면 필요한 경우에만 속성값 options의 값이 변하도록 만들 수 있음
### useMemo 훅은 꼭 필요할 때만 반환되는 값이 변경되도록 함
### useMemo 훅의 또 다른 중요한 역할은 입력된 함수를 최소한으로 실행한다는 점임
#### 배열의 크기가 상당히 크면 렌더링할 때마다 filter 연산을 수행한다고 했을 때 부담일 수 있음
#### useMemo 훅은 해당 값이 변하지 않으면불 필요한 filter 연산을 막아줌
## 무조건 useMemo, useCallback, React.memo를 사용하는 것은 좋지 않음
### 성능을 최적화하는 코드는 가독성이 나쁘고, 유지보수 비용을 증가시킴 => 성능 이슈가 발생했을 때 해당 부분의 코드만 최적화하는 것이 좋음
## 속성값이나 상탯값이 변경되면 반드시 객체도 새로 생성되어야 함
# 가상 돔에서의 성능 최적화
## 요소의 타입 또는 속성을 변경하는 경우
### 요소의 타입을 변경하면 해당 요소의 모든 자식 요소도 같이 변경됨
### 요소의 내용이 변경되지 않아도 실제 돔에서 삭제되고 다시 추가되므로 많이 비효율적임
## 리액트는 부모 요소의 타입이 변경되면 모든 자식 요소를 삭제하고 다시 추가함
### 부모 요소의 타입이 변경되면 자식 컴포넌트도 삭제 후에 다시 추가되므로 상탯값은 초기화됨
### 자식이 컴포넌트가 아닌 일반 요소인 경우, 실제 돔에서 제거하고 다시 추가함
### 자식 요소가 많은 부모 요소의 타입을 변경하면 화면이 끊기는 느낌이 들 수 있음
### 요소의 속성값만 변경하면 해당하는 속성만 실제 돔에 반영함
## 요소를 추가하거나 삭제하는 경우
### 새로운 요소를 추가하거나 삭제하면 해당 요소만 실제 돔에 추가 또는 삭제하고, 기존 요소는 건드리지 않음
#### 리액트는 가상 돔 비교를 통해 앞의 두 요소가 변경되지 않았음을 암
### 리액트는 중간에 요소를 추가하면 그 뒤에 있는 요소가 변경되지 않았다는 것을 알지 못함 => 이를 알기 위해선 모든 값을 비교해야 하므로 연산량이 많아짐
### 리액트는 효율적으로 연산하기 위해 순서 정보를 이용함
#### key 속성 값을 입력하면 같은 키를 가지는 요소끼리만 비교하여 변경점을 찾음 => 이를 통해 리액트는 특정 요소가 변경되지 않았음을 앎
#### key 속성값은 리액트가 렌더링을 효율적으로 할 수 있도록 우리가 제공하는 추가 정보로 대부분의 데이터는 ID 값이 있으므로, 그 값을 key 속성값에 입력하면 됨
##### key 속성값에 입력할만한 값이 없다면 차선책으로 배열 내에서의 순서(index) 정보를 입력할 수 있음 => 배열 중간에 원소를 추가하거나 삭제하는 경우 또는 원소의 순서가 변경되는 경우에는 비효율적으로 렌더링됨
##### key 속성값에 순서 정보를 입력하는 것은 배열의 끝에서만 원소를 추가하거나 삭제하면서 원소의 순서를 변경하지 않는 경우에 적합함
### 배열 중간에 원소를 추가하거나 삭제할 경우 또는 배열을 새롭게 정렬하는 경우에는 key 속성 값으로 순서 정보를 입력하는 것은 옳지 않음