# 훅이 등장하면서 클래스 컴포넌트를 사용할 일이 거의 적음
## 신규 프로젝트에서는 클래스 컴포넌트보다 훅을 사용하여 함수형 컴포넌트로 작성하는 게 좋음
## 기존 클래스형 컴포넌트를 무리하게 함수형 컴포넌트로 변환할 필요도 없음
### 리액트에서 클래스형 컴포넌트의 지원을 갑자기 중단할 것 같지 않기 때문임

# 클래스형 컴포넌트의 생명 주기 메서드
> 모든 컴포넌트는 다음과 같이 세 단계를 거침
>> 초기화 단계 -> 업데이트 단계 -> 소멸 단계
>> 각 단계에선 몇 개의 메서드들이 정해진 순서대로 호출됨
>> 각 단계 속에서 호출되는 메서드를 생명 주기 메서드라고 함
>>> 초기화 단계는 최초에 컴포넌트 객체가 생성될 때 한번 수행됨
>>>> 초기화 단계에서 호출되는 생명 주기 메서드의 호출 순서는 constructor() -> static getDerivedStateFromProps() -> render() -> componentDidMount() 순으로 호출됨
>>> 업데이트 단계는 초기화 단계와 소멸 단계 사이에서 반복해서 수행됨
>>>> 컴포넌트의 속성값 또는 상탯값이 변경되면 업데이트 단계가 수행됨
>>>> 업데이트 단계에서 실행되는 생명 주기 메서드의 호출 순서는 static getDerivedStateFromProps() -> shouldComponentUpdate() -> render() -> getSnapshotBeforeUpdate() -> componentDidUpdate() 순으로 호출됨
>>> 소멸 단계에서는 componentWillUnmount()가 호출됨
>>> 초기화, 업데이트, 소멸 단계와 별개로 렌더링 시, 예외가 발생되면, static getDerivedStateFromError()와 componentDidCatch()가 호출됨

# 생명 주기 메서드를 한 장의 페이지로 잘 정리한 사이트를 북마크로 하는 게 좋음

# 생명 주기 메서드를 잘못된 방식으로 사용하는 경우도 많이 발생함
## constructor 메서드에서 setState 메서드를 호출하거나, render 메서드에서 API를 호출하는 것은 잘못된 사용법임

# constructor 메서드의 구조는 하기와 같다.
## constructor(props)
## props 매개변수는 컴포넌트의 기본 속성값(defaultProps)이 적용된 상태로 호출됨
## constructor 메서드 내부에서 반드시 super 함수를 호출해야 함
### super 함수를 호출해야 React.Component 클래스의 constructor 메서드가 호출됨
### super 함수를 호출하지 않으면 컴포넌트가 제대로 동작하지 않음
### 리액트 개발 모드에서는 super 함수를 호출하지 않는 경우 예외를 발생시킴
## 상탯값을 직접 할당하는 것은 constructor 메서드에서만 가능함
### 다른 생명 주기 메서드에서 상탯값을 변경할 때는 setState 메서드를 사용해야 함
### 초기 속성 값을 이용하여 상탯값을 정의하기 위해 constructor 메서드를 작성하는 경우가 많음

## 자바스크립트 표준이 될 것을 거의 확실한 클래스 필드(class fields)를 사용하면 constructor 메서드를 사용하지 않고 같은 기능을 구현할 수 있음
### 자바스크립트 표준은 TC39로 불리는 위원회에 의해서 정해짐
### 새로운 기능이 표준으로 채택되기 위해서는 stage 0부터 stage 4까지의 단계를 거쳐야 함
### stage 0는 새로운 기능을 누구나 제안할 수 있는 초기 단계
### stage 4는 모든 절차가 마무리되어서 표준으로 채택되는 단꼐임
### stage 3은 완성도가 높은 단계이므로 특별한 이유가 없는 한 stage 4로 올라감
## 클래스 필드를 사용하면 constructor 메서드를 사용하지 않고, 초기 속성 값으로부터 상탯값을 정의할 수 있음
### 클래스 필드 문법은 create-react-app에서도 지원함
### 상탯값이 속성값에 항상 의존적이라면 별도의 함수를 만들어서 필요할 때마다 함수를 호출하는 것이 좋음

# setState 메서드 호출은 컴포넌트가 마운트된 이후에만 유효하기 때문에 constructor 메서드 내부에서 호출되는 setState 메서드는 무시됨
## constructor 메서드에서 비동기로 데이터를 가져온 후 setState 메서드를 호출하는 것도 문제가 될 수 있음
## constructor 메서드에서 비동기로 받아온 데이터를 setState 메서드를 이용하여 상탯값으로 저장하면 앞의 코드에서 마운트 되기 전에 데이터가 도착하여 setState의 호출이 무시됨
## 데이터를 가져오기 위해 호출하는 API는 componentDidMount 메서드 내부에서 호출하는 게 적합함

# getDerivedStateFromProps 메서드는 속성값을 이용하여 새로운 상탯값을 만들 때 사용되며, render 메서드가 호출되기 직전에 호출됨
## static getDerivedStateFromProps(props, state)
## 정적 메서드이기 때문에 함수 내부에서 this 객체에 접근할 수 없음
## 오로지 속성값과 상탯값을 기반으로 새로운 상탯값을 만듦

# getDerivedStateFromProps 메서드는 시간에 따라 변하는 속성값으로부터 상탯값을 계산하기 위해 추가됨
## 주로 애니메이션과 관련된 속성값으로부터 상탯값을 계산할 때 유용하게 사용됨
## 이를테면 특정 요소의 Y축 위치가 속성값일 때 스크롤 여부를 상탯값으로 저장하는 용도로 사용됨
## 매개변수에 현재 속성값은 있어도 이전 속성값은 존재하지 않음

# 리액트 팀에서 getDerivedStateFromProps 메서드의 매개변수에 이전 속성값을 넣지 않은 이유
## 이전 속성값을 넣을 경우, 최초에 호출될 때는 이전 속성값이 없기 때문에 항상 null을 검사하는 코드가 필요함
## 앞으로 모든 생명 주기 메서드의 매개변수에서 이전 속성값을 제거할 예정임
## 이전 속성값이 필요 없어지면, 더 이상 메모리에 담고 있지 않아도 되므로 메모리 절약이 가능함

# 속성값 변화에 따른 추가적인 처리를 getDerivedStateFromProps 메서드에서만 할 수 있는 것은 아님
## getDerivedStateFromProps 메서드를 잘못 사용하는 경우
### 속성값 변화에 따라 API를 호출해야 하는 경우
### 속성값을 입력으로 하는 메모이제이션(memoization)을 상탯값으로 관리하는 경우
### 속성값이 변경될 때 상탯값을 초기화하는 경우

# getDerivedStateFromProps는 정적 메서드이므로 this 객체에 접근할 수 없음
## 보통 API 호출은 this 객체가 필요한 경우가 많으므로 getDerivedStateFromProps 메서드로 해결되지 않음
## componentDidUpdate 메서드에서 처리가 가능함

# 메모이제이션은 불필요한 계산량을 줄이기 위한 기술임
## 같은 입력값에 대해 항상 같은 출력값이 나온다면 메모이제이션을 이용할 수 있음
## getDerivedStateFromProps 메서드를 이용한 메모이제이션은 최소 두 개의 상탯값이 필요함
### 상탯값이 많아지면 컴포넌트 코드가 복잡해지므로 되도록 상탯값의 갯수를 최소화하는 것이 좋음
### 메모이제이션을 위해 getDerivedStateFromProps 메서드를 이용하는 것보다 render 메서드에서 직접 메모이제이션을 하는 게 좋음

# getDerivedStateFromProps 메서드에서 속성값 변경 시 상탯값을 초기화하는 코드는 지양하는 게 좋음
## 컴포넌트에 key 속성값을 부여하고 key 값을 변경하면 이전의 컴포넌트 인스턴스는 사라지고 새로운 인스턴스가 생성됨

# getDerivedStateFromProps 메서드가 유의미한 경우는 이전 속성값과 이후 속성값 모두에 의존적인 상탯값이 필요할 때임

# render 메서드는 컴포넌트를 정의할 때 반드시 작성해야 함
## render 메서드의 반환값은 화면에 보여질 내용을 결정하며, 속성값과 상탯값만으로 결정되어야 함
## 속성값과 상탯값이 변하지 않았다면 render 메서드의 반환값도 변하지 않아야 함
## render 메서드에서는 부수 효과를 발생 시키면 안 됨
### 서버와 통신하기, 브라우저의 쿠기에 저장하기 등은 부수 효과이므로, render 메서드 내부에서는 피해야 함
### 부수 효과가 필요하다면 다른 생명 주기 메서드에서 진행하면 됨

# componentDidMount 메서드는 render 메서드의 첫 번째 반환값이 실제 돔에 반영된 직후 호출됨
## render 메서드에서 반환한 리액트 요소가 돔에 반영되어야 알 수 있는 값을 얻을 수 있음
### CSS 코드에서 width: 100%로 표현된 요소는 돔에 반영된 후에 픽셀 단위의 가로 길이를 알 수 있음

# componentDidMount 메서드에서 setState 메서드를 호출하면 다시 렌더링됨
## componentDidMount 메서드는 API 호출을 통해 데이터를 가져올 때 적합함
### setState 메서드가 마운트 이후에만 동작하기 때문임

# constructor 메서드에서 API 호출 후, setState 메서드를 호출하면 데이터가 저장되지 않을 수 있음
## constructor 메서드가 componentDidMount 메서드보다 먼저 호출되기 때문에 API 호출 결과를 더 빨리 받아올 수 있다는 것엔 변함이 없음
## constructor 메서드에서 API를 호출하고, componentDidMount 메서드에서 setState를 호출하는 방법은 프로미스를 이용하는 것임
### 이 방법은 코드가 복잡해지는 단점이 존재하며, 응답 속도에 민감한 애플리케이션이 아니라면 componentDidMount에서 API를 호출하는 게 좋음

# requestData 함수는 API 호출을 하고 프로미스 객체를 반환함

# shouldComponentUpdate 메서드는 렌더링 성능 최적화를 위해 존재함
## shouldComponentUpdate(nextProps, nextState);
## 이 메서드는 불 타입을 반환함
## 참을 반환하면 render 메서드가 호출되고, 반대로 거짓을 반환하면 업데이트 단계는 여기서 멈춤
## 개발자가는 속성값과 상탯값을 기반으로 거짓 혹은 참을 반환하는 코드를 작성함

# shouldComponentUpdate 메서드에서 참을 반환하면 render 메서드가 호출되고, 가상 돔 수준에서 변경된 내용이 있는지 비교함
## 한 번의 변수 비교를 통해 불필요한 연산을 줄일 수 있는 효과를 보일 수 있음
## 이 메서드가 별도로 구현되지 않은 경우, 항상 참을 반환하는 함수가 사용됨
### 이 때는 실제 돔이 변경되지 않는 상황에서도 항상 가상 돔을 비교하게 됨
## 하지만 성급하게 성능을 고려해서 개발할 필요는 없으므로, 성능 이슈가 발생했을 때 shouldComponentUpdate 메서드를 작성해도 괜찮음

# getSnapshotBeforeUpdate 메서드는 렌더링 결과가 실제 돔에 반영되기 직전에 호출됨
## getSnapshotBeforeUpdate(prevProps, prevState) => snapshot
## getSnapshotBeforeUpdate 메서드가 호출되는 시점에 이전 돔 요소의 상탯값을 가져오기 쉬움
## 업데이트 단계에서 실행되는 생명 주기 메서드의 호출 순서는 static getDerivedStateFromProps() -> shouldComponentUpdate() -> render() -> getSnapshotBeforeUpdate() -> componentDidUpdate() 순으로 호출됨
### getSnapshotBeforeUpdate 메서드와 componentDidUpdate 사이에 가상 돔이 실제 돔에 반영됨
### componentDidUpdate 메서드가 호출될 때에는 실제 돔이 새로운 상태로 변경된 상태임
### getSnapshotBeforeUpdate 메서드가 반환한 값은 componentDidUpdate 메서드의 세 번째 인자로 들어감
### getSnapshotBeforeUpdate 메서드에서 이전 돔의 상탯값을 반환하면 componentDidUpdate 메서드에서 돔의 이전 상탯값과 이후 상탯값을 모두 알기에 돔의 상탯값 변화를 알 수 있음

# createRef 함수가 반환한 값은 ref 속성값에 입력해서 사용해야 함

# componentDidUpdate 메서드는 업데이트 단계에서 마지막으로 호출되는 생명 주기 메서드임
## componentDidUpdate(prevProps, prevState, snapshot)
## componentDidUpdate 메서드는 가상 돔이 실제 돔에 반영된 후 호출됨
## componentDidUpdate는 새로 반영된 돔의 상탯값을 가장 빠르게 가져올 수 있는 생명 주기 메서드임
## componentDidUpdate 메서드는 속성값이나 상탯값이 변경된 경우, API를 호출하는 용도로 사용되기도 
## componentDidUpdate는 초기화 단계에서는 호출되지 않음
## componentDidMount 메서드와 componentDidUpdate 메서드 양쪽에서 데이터를 불러오는 구조의 패턴이 많이 사용되나, componentDidUpdate 메서드가 첫 렌더링 직후 호출되지 않는 이유로 코드가 복잡해짐
### 비슷한 로직을 양쪽 모두에서 작성되기 때문에 코드 중복이 발생되고, 한 쪽에 코드 작성하는 것을 깜빡하면 버그가 발생되기도 함

# componentWillUnmount 메서드는 소멸 단계에서 호출되는 유일한 생명 주기 메서드임
## 끝나지 않는 네트워크 요청을 취소, 타이머 해제, 구독(subscription) 해제 등의 작업을 처리할 때 유용함
## 컴포넌트에서 componentDidMount 메서드가 호출되면 componentWillUnmount 메서드도 호출되는 것이 보장됨
## componentDidMount 메서드에서 구독하고 componentWillUnmount 메서드에서 구독을 해제하는 코드가 많이 사용됨
### 특정 돔 요소에 addEventListener 함수를 이용하여 이벤트 처리 함수를 등록하고, removeEventListener 함수를 이용하여 등록을 해제할 수 있음
### 이런 패턴은 두 생명 주기 메서드의 코드가 길어질수록 서로 연관된 등록과 해제 코드가 물리적으로 멀어진다는 단점이 있음
#### 등록하는 코드는 존재하고 해제하는 코드를 깜빡해서 버그가 생기는 문제도 종종 발생함
### componentDidUpdate와 마찬가지로 리액트 훅에서 이 문제를 쉽게 해결할 수 있음

# getDerivedStateFromError, componentDidCatch 메서드는 생명 주기 메서드에서 발생된 예외를 처리할 수 있음
### static getDerivedStateFromError(error)
### componentDidCatch(error, info)
#### error 매개변수는 예외가 발생할 때 전달된 에러 객체임
#### info 매개변수는 어떤 컴포넌트에서 예외가 발생했는지 알려줌
## 생명 주기 메서드에서 예외가 발생하면 getDerivedStateFromError 또는 componentDidCatch 메서드를 구현한 가장 가까운 부모 컴포넌트를 찾음
## getDerivedStateFromError 정적 메서드는 에러 정보를 상탯값에 저장해서 화면에 나타내는 용도로 사용됨
## componentDidCatch 메서드는 에러 정보를 서버로 전송하는 용도로 사용됨
### 현재에는 componentDidCatch 메서드에서도 에러 정보를 상탯값에 저장해서 화면에 나타날 수 잇으나, 추후 componentDidCatch에서의 setState 호출이 막힐 것으로 보임
#### componentDidCatch 메서드는 렌더링 결과를 돔에 반영한 후에 호출되기 때문에 몇 가지 문제가 존재하므로, 서버사이드 렌더링 시 에러가 발생해도 componentDidCatch 메서드는 호출되지 않음

# componentDidCatch 메서드에서 에러 정보를 서버로 전송하는 이유
## componentDidCatch 메서드를 작성하지 않고, getDerivedStateFromError 메서드에서 에러 정보를 서버로 전송해도 되지 않는 게 좋음
### concurrent 모드 때문임
## 리액트에서 데이터 변경에 의한 화면 업데이트는 렌더 단계(render phase)와 커밋 단계(commit phase)를 거침
## 렌더 단계에서는 실제 돔에 반영할 변경 사항을 파악하고, 커밋 단계에서는 파악된 변경 사항을 실제 돔에 반영함
## concurrent 모드에서는 렌더 단계에서 실행을 멈췄다가 나중에 다시 실행하는 과정에서 같은 생명 주기 메서드를 여러 번 호출할 수 있음
## 커밋 단계에서 호출되는 생명 주기 메서드는 getSnapshotBeforeUpdate -> componentDidMount -> componentDidUpdate -> componentDidCatch 순으로 호출됨
## 이 메서드들을 제외한 나머지 생명 주기 메서드는 렌더 단계에서 호출됨
### getDerivedStateFromError 메서드는 렌더 단계에서 호출되고, componentDidCatch 메서드는 커밋 단계에서 호출됨
#### getDerivedStateFromError 메서드에서 에러 정보를 서버로 전송한다면 같은 에러 정보가 여러 번 전송될 수 있음
#### 커밋 단꼐의 생명 주기 메서드는 concurrent 모드에서도 한 번만 호출되기 때문에 에러 정보는 componentDidCatch에서 전송하는 게 좋음

# ErrorBoundary 컴포넌트를 애플리케이션의 최상위 컴포넌트로 만들면 생명 주기 메서드에서 발생되는 에러를 모든 예외로 처리할 수 있음
## render 메서드는 생명 주기 메서드이므로 발생한 예외는 ErrorBoundary 컴포넌트에서 처리할 수 있음
## ErrorBoundary 컴포넌트는 애플리케이션의 최상위 컴포넌트가 아니어도 됨
### 단, ErrorBoundary 컴포넌트의 자식 컴포넌트에서 발생한 예외만 처리할 수 있음
### ErrorBoundary 컴포넌트는 여러 곳에서 사용해도 괜찮으나, 에러가 발생한 일부 화면에만 에러 정보가 렌더링되고, 나머지 부분은 정상적으로 렌더링됨

# 리액트는 예외 발생 시, ErrorBoundary 컴포넌트로 처리되지 않으면 모든 컴포넌트를 언마운트함
## 이는 잘못된 정보를 사용자에게 보여주는 것보다는 아무것도 보여주지 않는 것이 낫기 때문임
### 예시로 은행 사이트에서 예외가 발생했을 때 사용자에게 잘못된 숫자를 보여주는 것보다는 ErrorBoundary 컴포넌트를 이용하여 에러 화면을 보여주는 게 더 나음
#### 하지만 아무 것도 보여주지 않는 것보다는 ErrorBoundary 컴포넌트를 이용하여 에러 화면이라도 보여주는 게 더 나음
### 이벤트 처리 메서드에서 발생하는 예외는 ErrorBoundary 컴포넌트로 처리되지 않음
#### 이벤트 처리 메서드는 생명 주기 메서드가 아니기 때문임
#### 이벤트 처리 메서드에서는 try/catch 문을 이용하여 예외 처리를 해야 함

# setState는 클래스형 컴포넌트에서 상탯값을 변경할 때 호출되는 메서드임
## setState 메서드로 입력된 객체는 기존 상탯값과 병합됨
## 리액트는 setState 메서드가 호출되면 해당 컴포넌트를 다시 렌더링함

# setState는 비동기로 상탯값을 변경함
## 리액트는 효율적으로 렌더링하기 위해 여러 개의 setState 메서드를 배치(batch)로 처리함
## setState 메서드로 입력된 함수는 자신이 호출되기 직전의 상탯값을 매개변수로 받음
### 앞의 코드에서 호출한 setState가 변경한 상탯값이 두 번째 setState 호출의 인수로 사용된다고 이해하면 됨

# setState 메서드의 인수로 함수를 전달할 수 있으므로 상탯값을 관리하는 코드를 따로 분리할 수 있음

# setState 메서드가 비동기로 처리되기 때문에 처리된 시점을 알고 싶을 때, setState 메서드의 두 번째 매개변수는 처리가 끝났을 떄 호출되는 콜백 함수임
## setState 메서드의 두 번째 매개변수를 이용하여 count 상탯값 변경이 완료되면 로그를 출력함
## 콜백 함수는 상탯값 변경 후에 호출되기 때문에 변경된 상탯값을 기반으로 다음 작업을 처리할 때 유용하게 사용됨

# 속성값은 값을 수정하려고 하면, 에러가 발생하지만 상탯값은 직접 수정이 가능함
## 직접 수정 후, forceUpdate 메서드를 호출하면 새로운 값과 함꼐 화면을 다시 그림
### 하지만 상탯값도 속성값과 같이 불변 객체로 관리하는 게 좋음
### 불변 객체로 관리하면 코드의 복잡도가 낮아지고, 렌더링 성능도 좋아짐

# 클래스 필드 (class field)를 이용해서 이벤트 처리 메서드를 작성하면 함수에 바인딩을 적용하면서 렌더링 성능과 가독성을 향상시킬 수 있음
## 기존에 많이 사용되는 방식에서는 렌더링 선으과 가독성 중에서 하나를 선택해야 했음
## 클래스 필드는 아직 JS 표준은 아니나, 표준이 거의 확실시 되므로, 바벨을 이용해서 안심하고 사용할 수 있음

# 함수 바인딩이 필요한 이유
## 클래스형 컴포넌트의 이벤트 처리 메서드는 자식 컴포넌트 또는 돔 요소의 속성 값으로 전달할 수 있음
## 이 때 이벤트 처리 메서드와 this 객체를 바인딩하지 않으면 메서드 호출 시 엉뚱한 객체를 가리킬 수 있음
## 함수 바인딩을 통해 this 객체를 고정시킬 필요가 존재함
 
# render 메서드 내부에서 바인딩하는 게 작성하는 것이 더 편하지만, 생성자 안에 바인딩 하는 경우는 성능 때문임
## 함수를 바인딩할 때마다 새로운 함수가 생성되므로 render 메서드 내부에서 함수를 바인딩하는 건 성능에 마이너스 요소가 되므로 성능 우선이면 생성자 안에서 바인딩하는 게 좋음
### 생성자 안에서 바인딩하는 건 개발자 입장에선 번거로움 => 이벤트 처리 메서드를 작성한 후 기계처럼 반복적으로 생성자로 돌아가서 또 다시 같은 메서드명을 이용해 바인딩하는 코드를 작성해야 함

# 함수 생성이 성능에 미치는 영향
## render 메서드는 렌더링이 발생할 때마다 호출됨
## render 메서드 내부에서 새로운 함수를 생성하면 성능에 부정적인 영향을 미침
## render 메서드에서 새로운 함수의 두 가지 생성 방법은 화살표 함수 혹은 일반 함수를 render 메서드 내부에서 구현하여 render 메서드가 호출될 때마다 새로운 함수를 생성하는 방법과 함수의 bind 메서드를 호출하는 방법임
### 일반적으로 bind 방식이 화살표 함수/일반 함수 생성 방식보다 성능에 더 큰 영향을 줌
#### 하지만 성능 개선이 많이 이루어진 최근 브라우저에서는 함수 생성이 성능에 미치는 영향을 크지 않음 => 단, 오래된 브라우저도 지원해야 하는 경우, bind 메서드를 사용한 함수 생성은 성능 저하를 일으킬 수 있어 주의해야 함
#### 브라우저 성능이 개선된 덕분에 리액트 버전 16.8부터 도입된 혹은 렌더 함수 내부에서의 함수 생성을 적극적으로 활용함
*** 이 책에서만 클래스형 컴포넌트의 render 메서드와 함수형 컴포넌트를 모두 렌더 함수라고 함

# 생성자 내에서 bind 메서드 없이 바인딩하는 방법은 클래스 필드에서 화살표 함수를 이용하여 this 객체를 자동으로 바인딩 하는 것임
## 클래스 인스턴스가 생성될 때 한 번만 바인딩되므로 렌더링 성능에도 문제가 없음

# 컨텍스트 데이터는 생명 주기 메서드에서도 사용할 수 있음
## 클래스형 컴포넌트의 contextType 정적 멤버 변수에 컨텍스트 객체를 입력하면 클래스 내부에서 컨텍스트 데이터에 접근할 수 있음
## 클래스 내부에서 컨텍스트 데이터에 접근하기 위해 contextType 정적 멤버 변수에 컨텍스트 객체를 입력함
### 생명 주기 메서드에서 context 멤버 변수를 통해서 컨텍스트 데이터 사용이 가능함
### contextType을 이용한 방법은 하나의 컨텍스트만 연결할 수 있다는 단점이 있음

# 컴포넌트에서 공통 로직은 함수로 만들어서 사용하면 되고, 공통 버튼은 컴포넌트를 만들어서 재사용하면 되며, 원주율은 상수 변수로 만들어서 사용하면 됨
# 컴포넌트 공통 로직은 함수형 컴포넌트에선 훅을 이용하여 간단하게 공통 기능을 관리할 수 있으나, 클래스형 컴포넌트에서는 훅을 사용할 수 없음
## 고차 컴포넌트 (Higher Order Component)와 렌더 속성값(Render Props) 패턴을 이용하면 해결할 수 있음

# 고차 컴포넌트는 입력으로 받아서 컴포넌트를 출력해주는 함수임
## 이 함수에서 출력되는 컴포넌트는 내부적으로 입력받은 컴포넌트를 사용함
### 이 때, 입력된 컴포넌트를 활용하는 건 무궁무진임

# 어떤 화면이 사용자에게 자주 노출되는지 확인하고자 하는 경우, 화면이 사용자에게 보이는 시점은 그 화면의 최상위 컴포넌트가 마운트되는 시점임
## 이럴 때, 각 화면의 최상위 컴포넌트가 마운트될 때마다 서버에 이벤트를 전달하면 됨
### 가장 단순한 방법은 필요한 모든 컴포넌트에 componentDidMount 생명 주기 메서드를 만들고 그 안에서 서버에 이벤트를 보내는 것임
#### 서버에 이벤트를 보내는 로직은 공통 함수를 만들어서 처리하더라도 모든 컴포넌트가 똑같은 생명 주기 메서드 안에서 똑같은 함수를 호출하면 코드 중복임

# 고차 컴포넌트로 만들어진 모든 컴포넌트는 마운트될 때마다 서버로 이벤트를 보냄
## 서버로 마운트 이벤트를 보내는 기능의 함수가 구현하는 것임
## export default로 해당 함수를 꺼낼 때, 공통 기능을 적용하고 싶은 컴포넌트를 고차 컴포넌트의 인수로 입력함

# 출력되는 컴포넌트의 속성값으로 추가 정보를 제공하는 고차 컴포넌트도 많이 사용됨
## react-readux의 connect 함수가 대표적인 예
## 서버 렌더링을 사용하는 프로젝트에서는 화면 일부분이 클라이언트 측에서만 렌더링되기를 원하는 경우가 많이 발생함
## 마운트 이후에만 렌더링함녀 클라이언트 측에서만 렌더링되므로 마운트 정보가 자주 사용됨

# 고차 컴포넌트 내부에서 속성값 일부를 사용하고, 입력된 컴포넌트로 나머지 속성값만 내려 주는 게 가능함

# 상속되어 생성된 컴포넌트는 입력된 컴포넌트의 멤버 변수와 메서드에 접근할 수 있음
## 입력된 컴포넌트로 만들어진 인스턴스의 속성값, 상탯값, 생명 주기 메서드, 기타 멤버 변수 및 메서드에 접근할 수 있다는 것
### 특정 컴포넌트의 속성값과 상탯값을 디버깅하고 싶은 경우, 리액트 개발자 도구를 사용해도 되나, 특정 이벤트 발생 시 해당 컴포넌트가 언마운트 후 다시 마운트되는 상황이면 리액트 개발자 도구는 불편해짐


# 어떤 컴포넌트라도 렌더링된 최상위 요소는 div 요소로 강제하고 싶은 경우, 먼저 입력된 컴포넌트가 div 요소를 최상위 요소로 출력되는지 확인해야 함
## 이를 위해선 입력된 컴포넌트의 render 메서드를 호출해야 함
### 그리고 render 메서드의 결괏값에서 최상위 요소가 div 요소가 아니라면 그 결괏값을 div 요소로 감싸면 됨
## render 메서드 이외에도 입력된 컴포넌트 내부의 모든 메서드를 호출하는 것이 가능함 (단, 생명 주기 메서드는 호출하지 않는 게 좋음 => 각 생명 주기 메서드는 항상 약속된 시점에 호출되어야 되므로 강제로 호출하면 버그가 발생함)

# 기능을 잘게 쪼개서 너무 많은 수의 고차 컴포넌트를 사용하면 렌더링 성능이 나빠질 수 있음
## 리액트 개발자 도구에서 디버깅할 때에도 불편하므로 고차 컴포넌트는 필요한 만큼만 사용하는 게 좋음
## 리액트 개발자 도구에서 디버깅을 편하기 하기 위해 displayName을 수정하면 좋음
## recompsoe 패키지에서 제공하는 getDisplayName 함수를 이용하면 쉽게 적용할 수 있음

# 고차 컴포넌트를 사용할 때 주의할 점은 입력되는 컴포넌트가 정적 메서드를 가지고 있을 때임
## 고차 컴포넌트를 사용하는 순간 입력되는 컴포넌트의 정적 메서드는 출력되는 컴포넌트에 전달되지 않음
## 이를 해결하기 위해 hoist-non-react-statics 패키지를 많이 사용함

# 리액트 라우터의 고차 컴포넌트
## 단일 페이지 애플리케이션(SPA)을 만들 때 많이 사용되는 리액트 라우터(react-router)의 withRouter 고차 컴포넌트가 존재함

# 고차 컴포넌트의 단점은 아래와 같음 => 단점이 존재해도 남아있는 이유는 반복되는 코드의 재사용이 가능하도록 만들기 때문
## 첫째, 고차 컴포넌트를 사용하면 속성값이 암묵적으로 넘어옴
### react-redux의 connect 고차 컴포넌트를 사용하면 사용자가 명시한 속성값 외에도 dispatch라는 함수가 암묵적으로 넘어옴
### connect 고차 컴포넌트를 사용한 컴포넌트 내부에서는 this.props.dispatch라는 코드가 등장하게 됨
### connect 고차 컴포넌트에 익숙한 사람이면 코드를 읽는데 큰 불편함이 없으나, 고차 컴포넌트의 종류가 많아지면 헷갈리고, react-redux 문서를 찾게 됨
## 둘째, 서로 다른 고차 컴포넌트가 똑같은 속성값 이름을 사용할 때 발생함
### 어떤 고차 컴포넌트가 dispatch라는 새로운 속성값을 만들어낸다고 할 때, 이 고차 컴포넌트와 react-redux의 connect 고차 컴포넌트를 동시에 사용하면 속성값 이름이 충돌하는 문제가 존재함
### 마지막, 호출된 고차 컴포넌트의 속성값으로 덮어씌워짐
### 하나의 고차 컴포넌트만 사용해도 같은 문제가 발생될 수 있음
### 입력된 컴포넌트가 원래 dispatch라는 속성값을 가지고 있을 때 문제가 됨
#### 이 때, 컴포넌트를 사용할 때 입력된 dispatch 속성값은 고차 컴포넌트가 생성한 값으로 덮어씌워짐
### 우리가 만든 컴포넌트라면 속성값 이름을 수정하면 쉽게 해결되나, 고차 컴포넌트와 입력된 컴포넌트가 모두 외부 패키지의 것이라면 같이 사용하는 데 어려움이 존재함
## 셋째, 의례적인 절차(ceremony)가 필요함
### 고차 컴포넌트를 만들 때는 항상 함수로 감싸줘야 하고, displayName을 설정해줘야 하고, 정적 메서드를 전달하기 위한 코드가 필요함
### 함수로 감싸져 있다는 부분은 타입스크립트(TypeScript)와 같은 정적 타입 언어를 사용할 때, 타입을 정의하기 까다로워짐

# 같은 기능을 구현할 수 있는 방법은 고차 컴포넌트를 활용하거나 렌더 속성값으로 구현할 수 있음

# 렌더 속성값이란 코드 재사용을 위해 함수 타입의 속성값을 이용하는 패턴을 말함
## 렌더 속성값은 children 뿐만이 아닌 다른 속성값 이름을 사용해도 무관함

# 서버로부터 데이터를 가져오고 사용하는 과정에서 코드 중복이 발생될 수 있으므로, 일반적으로 componentDidMount 생명 주기 메서드에서 서버로 요청을 보냄
## 렌더 함수에서는 데이터가 아직 도착하지 않았다면 로딩 애니메이션을 보여주거나 null을 반환함

# axios는 API 호출 시 많이 사용되는 유명 패키지임

# 렌더 함수 내부에서는 렌더 속성값을 위한 함수를 정의하고, 그 함수는 약속된 매개변수와 함께 호출됨

# 렌더 속성값 구현이 어려운 경우, 렌더 속성값 함수의 매개변수를 컴포넌트의 속성값으로 전달해주는 래퍼(Wrapper) 컴포넌트를 이용하면 구현이 가능함

# 렌더 속성값은 아니지만, children을 함수로 사용하지 않고 단순히 리액트 요소를 사용하여도 많은 수의 코드 중복을 피할 수 있음

# 고차 컴포넌트 vs 렌더 속성값
## 렌더 속성값에는 고차 컴포넌트가 가지고 있는 모든 단점이 없음
## 렌더 속성값에서 데이터는 함수의 매개변수로 명시적으로 넘어옴
## 렌더 속성값은 함수의 매개변수를 통해서 개별적으로 필요한 정보를 주기 때문에, 고차 컴포넌트가 가지고 있던 속성값 이름 충돌 문제도 존재하지 않음
### 단, 생명 주기 메서드에서 렌더 속성값의 데이터에 접근하기 위해서 래퍼 컴포넌트를 사용하는 경우에는 여전히 이름 충돌 문제가 존재함
## 렌더 속성값은 고차 컴포넌트에서 필요했던 의례 절차가 없음
### 일반적인 리액트 컴포넌트이기 때문에 타입스크립트와 같은 정적 타입의 언어에서 타입을 정의하는 게 고차 컴포넌트만큼 까다롭지 않음
## 렌더 속성값의 첫 번째 단점은 렌더 함수가 호출될 때마다 새로운 함수를 만들기 때문에 성능에 부정적인 영향을 줌
### 최신 브라우저에서는 함수 생성이 성능에 영향이 없을 정도로 많이 개선되었으나, 오래된 브라우저에서도 높은 성능이 요구되는 프로그램이 아니라면 신경쓰지 않아도 됨
## 렌더 속성값의 두 번째 단점은 사용하는 쪽의 렌더 함수가 복잡해짐
## 고차 컴포넌트와 렌더 속성값은 모두 코드 재사용성을 높이기 위한 리액트 코딩 패턴으로 거의 모든 경우에 있어 고차 컴포넌트와 렌더 속성값으로 서로 변경할 수 있음
### 어느 쪽이 우월하다기보다, 각자의 취향과 프로젝트의 성격에 따라 어떤 패턴을 주로 사용할 지 선택하면 됨

# 훅은 기존에 리액트가 가지고 있던 여러가지 문제를 해결해 줌
## 컴포넌트를 새로 작성해야 하는 경우, 되도록 클래스 컴포넌트보다는 훅을 사용해서 함수형 컴포넌트로 작성하는 것이 좋음
## 훅이 가진 장점이 많고, 리액트 팀에서 훅과 관련된 기능 개발에 힘을 쏟고 있음

# 리액트에서 로직의 재사용은 주로 고차 컴포넌트와 렌더 속성값 패턴으로 이루어져 있음
## 두 방법은 대상이 되는 컴포넌트를 감싸는 새로운 컴포넌트를 생성하므로 리액트 요소 트리 깊이가 깊어질 수 있음
## 리액트 요소 트리가 깊어지면 성능에 부정적인 영향을 끼치고, 개발 시 디버깅을 힘들게 하는 원인이 됨

# 리액트 팀에서는 클래스형 컴포넌트에 본질적인 문제가 있다고 함
## 서로 연관성이 없는 여러 가지 로직을 하나의 생명 주기 메서드에서 작성하는 경우가 많음
## componentDidMount 메서드에서 등록하고, componentWillUnmount 메서드에서 해제하는 코드가 자주 사용되는데, 등록만 하고, 해제를 깜빡하는 실수를 하기 쉬움
## 함수형 컴포넌트에서는 상탯값이나 생명 주기 함수를 추가하기 위해, 클래스형 컴포넌트로 변경하는 작어도 상당히 번거로움
### 클래스형 컴포넌트로 작성할 때 부수적으로 작성해야 하는 코드가 많기 때문임
## 클래스형 컴포넌트는 사람뿐만이 아니라 컴퓨터 입장에서도 복잡한 구조로 되어 있음
### 클래스 사용 시, 코드 압축이 잘 안되는 경우가 존재하며, 핫 리로드(hot reload)에서 난해한 버그가 발생되어 컴파일 단계에서 코드를 최적화하기 어렵게 만듦

# 훅을 사용하면 재사용 가능한 로직을 쉽게 만들 수 있음
## 훅이 단순한 함수이므로, 함수 안에서 다른 함수를 호출하는 것으로 새로운 훅을 만들 수 있음
## 리액트의 내장 훅과 다른 사람이 만든 여러 커스텀 훅을 레고처럼 조립하여 쉽게 새로운 훅 제작이 가능함
## 훅을 사용하면 같은 로직을 한곳으로 모을 수 있어 가독성이 좋음
### 클래스형 컴포넌트의 생명 주기 메서드의 경우, 서로 다른 로직이 하나의 메서드에 섞여 있어서 가독성이 좋지 않음
#### 혹은 같은 로직이 componentDidMount와 componentDidUpdate 메서드에 중복으로 들어가기도 함
## 훅은 클래스가 아니라므로, 앞에서 나열한 클래스의 단점이 사라지며, 단순한 함수이므로 정적 타입 언어로 타입을 정의하는 것도 쉬움

# 리액트 버전 16.8에서는 getSnapshotBeforeUpdat, getDerivedStateFromError, componentDidCatch 메서드를 제외한 클래스형 컴포넌트의 모든 기능을 함수형 컴포넌트에서도 사용할 수 있음
## componentDidMount, componentWillUnmount 메서드는 useEffect 또는 useLayoutEffect 훅으로 대체할 수 있음
## 클래스의 멤버 변수는 useRef 훅으로 대체할 수 있음

# 클래스형의 constructor 메서드는 주로 속성값으로부터 초기 상탯값을 계산하는 용도로 사용됨
## componentDidMount보다 좀 더 빠르게 작업을 처리하는 용도로 사용됨

# 클래스형에서 constructor 메서드를 훅으로 변경하면 하기와 같음
## 속성값으로부터 계산된 초기 상탯값은 useState의 인수로 사용
## 컴포넌트 최초 호출 시에만 API 함수를 호출하기 위해 useRef 훅을 사용

# 클래스형 컴포넌트에서 최초 렌더링 후에는 componentDidMount 메서드가 호출되고, 이후에는 componentDidUpdate 메서드가 호출됨
## useEffect 훅은 최초 렌더링 후에도 호출되므로, 이를 피하기 위해 useRef 훅을 이용할 수 있음
## componentDidUpdate 메서드는 매개변수로 이전 상탯값과 이전 속성값을 전달함
### 리액트가 클래스형 컴포넌트의 인스턴스에 이전 값을 저장하여 제공해주기 떄문에 가능함
## 함수형 컴포넌트은 인스턴스가 없으므로 이전 값이 필요하다면 useRef 훅으로 직접 관리해야 함

# getDerivedStateFromProps 정적 메서드는 속성값 변경에 따라 상탯값도 변경할 때 사용함

# 리액트는 렌더 함수에서 상탯값을 변경하면 변경된 상탯값으로 렌더 함수를 다시 호출함
## getDerivedStateFromProps 정적 메서드를 사용한 방법보다는 조금 비효율적인 측면이 존재하나 돔을 변경하기 전에 발생하는 연산이므로 성능에 큰 영향을 미치지 않음
## 한 가지 주의사항은 렌더 함수가 무한대로 호출될 수 있으므로, 이전 속성값을 useState 훅이 아닌 커스텀 훅으로 관리하면 렌더 함수가 무한대로 호출될 수 있음

# forceUpdate 메서드의 사용은 지양해야 하나, 필요에 따라 구현할 수 있음
## forceUpdate 함수를 호출하면 상탯값이 항상 변경되므로 클래스형 컴포넌트의 forceUpdate처럼 동작함