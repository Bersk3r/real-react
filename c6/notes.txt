# 리덕스(redux)는 자바스크립트를 위한 상태 관리 프레임워크임
# 리액트를 사용하는 많은 프로젝트에서 리덕스도 같이 사용함
## 컴포넌트 코드로부터 상태 관리 코드도 분리할 수 있음
## 서버 렌더링 시, 데이터 전달이 간편함
## 로컬 스토리지에 데이터를 저장하고, 불러오는 코드를 쉽게 작성할 수 있음
## 같은 상탯값을 다수의 컴포넌트에서 필요로 할 때 좋음
## 부모 컴포넌트에서 깊은 곳에 있는 자식 컴포넌트에 상탯값을 전달할 때 좋음
## 알림창과 같은 전역 컴포넌트의 상탯값을 관리할 때 좋음
## 페이지가 전환되어도 데이터는 살아있어야 할 때 좋음

# 리덕스 사용 시 따라야 할 3가지 원칙
## 전체 상탯값을 하나의 객체에 저장함
## 상탯값은 불변 객체임
## 상탯값은 순수 함수에 의해서만 변경되어야 함

# 리덕스는 전체 상탯값이 하나의 자바스크립트 객체로 표현되기 때문에 활용도가 높아짐
## 리덕스를 사용하면 하나의 객체를 직렬화(serialize)해서 서버와 클라이언트가 프로그램의 전체 상탯값을 서로 주고 받을 수 있음
## 프로그램이 특정한 상태에 있을 때 발생하는 버그를 확인하기 위해 그 상탯값을 저장한 후 반복해서 재현할 수 있음
## 최근의 상탯값을 버리지 않고, 저장해놓으면 실행 취소(undo)와 다시 실행(redo) 기능을 쉽게 구현할 수 있음

# 프로그램의 전체 상탯값을 리덕스로 관리하는 것은 쉬운 일이 아님
## 애니메이션을 위한 데이터나 문자열 입력 창의 현재 상탯값은 컴포넌트에서 관리하는 게 더 나음
## 프로그램의 일부 상태만 리덕스를 활용해도 됨
## 특별히 로직이 복잡하지 않은 페이지에서는 컴포넌트의 상탯값을 활용하는 게 생산성을 더 높일 수 있음
## 전체 상탯값을 리덕스로 관리하면 시간 여행(time travel)과 같은 기능을 쉽게 구현할 수 있지만, 그런 기능을 사용하지 않는다면 필요한 곳에서만 리덕스를 사용해도 됨

# 리덕스는 상탯값을 불변 객체로 관리함
## 액션 객체는 type 속성값이 존재해야 함
### type 속성 값으로 액션 객체를 구분함
## type 속성값을 제외한 나머지는 상탯값을 수정하기 위해 사용되는 정보임
## 액션 객체와 함께 dispatch 메서드를 호출하면 상탯값이 변경됨
### 리덕스의 상탯값을 수정하는 유일한 방법은 액션 객체와 함께 dispatch 메서드를 호출하는 것임
#### 다른 어떤 방법으로도 상탯값을 수정하면 안 됨
## 상탯값은 dispatch 메서드가 호출된 순서대로 리덕스 내부에서 변경되기 떄문에 상탯값이 변화되는 과정을 쉽게 이해할 수 있음
## 액션 객체는 평범한 자바스크립트 객체이기 때문에 입력된 순서를 저장해놓고, 나중에 그 과정을 쉽게 재현할 수 있음
## 상탯값 수정이라는 하나의 목적만 놓고 보면 불변 객체를 사용하는 것보다는 상탯값을 직접 수정하는 게 더 빠름
## 이전 상탯값과 이후 상탯값을 비교해서 변경 여부를 파악할 때는 불변 객체가 훨씬 유리함
## 상탯값 변경을 빠르게 확인할 수 있으면 메모이제이션과 같은 기능을 활용하기 좋으며, 리액트의 렌더링 성능을 올리는 데도 유리함

# 오직 순수 함수에 의해서만 상탯값을 변경해야 함
## 리덕스에서 상탯값을 변경하는 함수를 리듀서(reducer)라고 부름
## 리듀서의 구조는 하기와 같음
### (state, action) => nextState
## 리듀서는 이전 상탯값과 액션 객체를 입력으로 받아서 새로운 상탯값을 만드는 순수 함수임
## 순수 함수는 부수 효과(side effect)를 발생시키지 않아야 함
## 순수 함수는 같은 인수에 대해 항상 같은 값을 반환해야 함
### 반환 값을 계산할 때, 랜덤 함수나 시간 함수를 이용하면 순수 함수가 아님
### 순수 함수는 테스트 코드를 작성하기 쉬움
## 리듀서는 순수 함수이기 때문에 같은 상탯값과 액션 객체를 입력하면 항상 똑같은 다음 상탯값을 반환함
## 실행된 액션 객체를 순서대로 저장했다가, 나중에 똑같은 순서대로 dispatch 메서드를 호출하면 쉽게 리플레이(replay) 기능을 구현할 수 있음

# 부수 효과는 전역 변수의 값을 수정한다거나, API 요청을 보내는 등 함수 외부의 상태를 변경시키는 것을 부수 효과라고 함

# 리덕스에서 상탯값이 변경되는 과정은 액션 -> 미들웨어 -> 리듀서 -> 스토어 -> 뷰 -> 액션 순으로 동작함
## 뷰는 리액트의 컴포넌트라고 얘기할 수 있음

# 액션(Action)은 type 속성값을 가진 자바스크립트 객체로, 액션 객체를 dispatch 메서드에 넣어서 호출하면 리덕스는 상탯값을 변경하기 위해 상탯값 변경 과정을 수행함
## 액션 객체에는 type 속성값 외에도 원하는 속성값을 얼마든지 넣을 수 있음
## 각 액션은 고유한 type 속성값을 사용해야 함
### type의 이름 중복을 막기 위해, 접두사를 붙이는 방법을 많이 사용함
### dispatch 메서드를 호출할 때, 직접 액션 객체를 입력하는 방법은 사용하지 않음
#### 액션 생성자 함수를 사용하면 이를 해결할 수 있음
#### 액션 생성자 함수를 필요한 인수와 함께 호출하면 항상 같은 구조의 액션 객체가 만들어짐
##### 액션 객체의 구조를 변경할 때는 액션 생성자 함수만 수정하면 됨
##### dispatch 메서드를 호출할 떄는 액션 생성자 함수를 이용함

# type 속성값은 리듀서에서 액션 객체를 구분할 때도 사용되기 때문에 상수 변수로 만드는 게 좋음
## 해당 변수는 리듀서에서도 필요하기 때문에 export 키워드를 이용해서 외부에 노출함
## 액션 생성자 함수도 외부에서 호출하므로 외부로 노출함

# 액션 생성자 함수에 부수 효과를 발생시켜도 괜찮음

# 미들웨어(Middleware)는 리듀서가 액션을 처리하기 전에 실행되는 함수로 디버깅 목적으로 상탯값 변경 시 로그를 출력하거나, 리듀서에서 발생한 예외를 서버로 전송하는 등의 목적으로 미들웨어를 활용할 수 있음
## 리덕스 사용 시 특별히 미들웨어를 설정하지 않았다면 발생한 액션은 곧바로 리듀서로 보내짐
## 미들웨어는 함수 세 개가 중첩된 구조로 되어 있으며, 화살표 함수가 연속으로 표현된 코드가 익숙하지 않다면 헷갈릴 수도 있음
### 미들웨어는 스토어와 액션 객체를 기반으로 필요한 작업을 수행할 수 있음
### next 함수를 호출하면 다른 미들웨어 함수가 호출되면서 최종적으로 리듀서 함수가 호출됨
### 미들웨어의 첫 번째 함수를 호출하면 next 매개변수를 갖는 두 번째 함수를 만들어짐
### 모든 미들웨어의 두 번째 함수를 체인으로 연결했으며 미들웨어가 3개면 3개를 연결함
### 외부에 노출되는 스토어의 dispatch 메서드는 미들웨어가 적용된 버전으로 변경됨
### 사용자가 dispatch 메서드를 호출하면 첫 번째 미들웨어 함수부터 실행되며, 마지막 미들우에어가 store.dispatch 메서드를 호출함

# dispatch 함수는 다음과 같이 동작함
## 리듀서 함수를 호출하여 상탯값 변경
## dispatch 메서드가 호출될 때마다 등록된 모든 이벤트 처리를 함수를 호출함
## 상탯값이 변경되지 않아도 이벤트 처리 함수를 호출하는 것에 주목할 것
## 상탯값 변경을 검사하는 코드는 각 이벤트 처리 함수에서 구현해야 함
## react-redux 패키지의 connect 함수에서는 자체적으로 상탯값을 변경함

# 미들웨어는 개발 환경에서 디버깅 목적으로 활용할 수 있음
# 리듀서 뿐만이 아닌 하위의 미들웨어 코드에서 발생하는 예외도 catch 문으로 들어옴

# 리듀서(reducer)는 액션이 발생했을 때 새로운 상탯값을 만드는 함수임
## (state, action) => nextState

# 리덕스는 스토어를 생성할 때, 상탯값이 없는 상태로 리듀서를 호출하므로, 매개변수의 기본값을 사용하여 초기 상탯값을 정의함
## 각 액션 타입별로 case 문을 만들어서 처리함
## 상탯값은 불변 객체로 관리해야 하므로 수정할 때마다, 새로운 객체를 생성함
### 전개 연산자를 사용하면 상탯값을 불변 객체로 관리할 수 있음
### 처리할 액션이 없다면 상탯값을 변경하지 않음
### 전개 연산자를 사용하더라도 수정하는 값이 깊은 곳에 있으면 수정이 어려움
#### 전개 연산자로 더 깊은 곳에 있는 값을 수정하면 코드의 가독성이 많이 떨어짐
## 자바스크립트에서 불변 객체를 관리할 목적으로 나온 여러 패키지가 있는데 여기서는 이머(immer) 패키지를 사용해서 설명함

# 리듀서 작성 시, 주의할 점 (데이터 참조)
## 리덕스의 상탯값은 불변 객체이기 때문에 언제든지 객체의 참조값이 변경될 수 있음
## 객체를 참조할 때는 객체의 참조값이 아니라 고유한 ID 값을 이용하는 게 좋음
## id 값으로 참조하면 객체의 데이터가 변경되어도 문제없이 데이터를 가리킬 수 있음

# 리듀서 작성 시, 주의할 점 (순수 함수)
## 리듀서는 순수 함수로 작성해야함
## 랜덤 함수를 사용하면 같은 인수로 호출해도 다른 값이 반환될 수 있으므로, 순수 함수가 아님
## API 호출은 부수 효과이기 때문에 API를 호출하는 함수는 순수 함수가 아님
### API 호출은 액션 생성자 함수나 미들웨어에서 하면 됨

# 리듀서 함수를 작성할 때 switch 문 외에 createReducer 함수를 이용하면 switch 문보다 더 간결하게 리듀서 함수를 작성할 수 있음
## createReducer 함수는 리덕스에서 제공하는 함수는 아니지만 리덕스 생태계에서 많이 사용됨
## createReducer 함수는 리듀서 함수를 반환하며, 초기 상탯값인 initialState 변수를 state 매개변수의 기본값으로 사용함
## 리듀서 함수 전체를 이머의 produce 함수로 감쌈
## 등록된 액션 처리 함수가 있다면 실행함

# 스토어(store)는 리덕스의 상탯값을 가지는 객체임
## 액션의 발생은 스토어의 dispatch 메서드로부터 시작됨
## 스토어는 액션이 발생하면 미들웨어 함수를 실행하고, 리듀서를 실행해서 상탯값을 새로운 값으로 변경함
## 사전에 등록된 모든 이벤트 처리 함수에서 액션의 처리가 끝났음을 알림

# 리덕스의 첫 번째 원칙에서 애플리케이션의 전체 상탯값을 하나의 스토어에 저장할 것
## 기술적으로 여러 개의 스토어를 만들어서 사용해도 문제가 되지 않음
## 단순히 데이터의 종류에 따라 구분하기 위한 용도라면 combineReducer 함수를 사용하면 됨
## 스토어는 하나만 생성하는 것이 좋음
## 외부에서 상탯값 변경 여부를 알기 위해서는 스토어에 이벤트 처리 함수를 등록하면 됨
### 스토어에 등록된 함수는 액션이 처리될 때마다 호출됨

# 프로그램 안에서 사용되는 데이터의 양이 많아지면, 데이터를 체계적으로 구조화하는 방법이 필요함
## 프로그램의 모든 액션을 하나의 파일에 작성하거나 모든 액션 처리 로직을 하나의 리듀서 함수로 작성할 수는 없음
## 보통 프로그램의 큰 기능별로 폴더를 만들어서 코드를 관리함
## 리덕스 코드도 각 기능 폴더 하위에 작성해서 관리하는 게 좋음
## 리덕스에 제공하는 combineReducer 함수를 이용하면 리듀서 함수를 여러 개로 분리할 수 있음
### 리듀서 함수를 여러 개로 작성하다 보면 공통 로직이 생길 수 있으며, 이를 별도로 분리하여 재사용할 수 있음

# 페이스북 웹 사이트를 구현한다고 가정하면 
## 타임라인과 친구 목록
### 타임라인에서는 사용자에게 보여 줄 열 개의 게시물을 관리해야 함
#### 각 게시물 데이터는 배열로 관리
### 게시물을 배열에 추가하거나 배열에서 삭제가 가능해야 함
#### 각 게시물의 좋아요 숫자는 변하는 값이므로 배열에 추가된 게시물 데이터를 수정할 수 있음
### 타임라인은 무한 스크롤 기능이 필요하므로, 이미 로딩된 데이터의 끝에 도달한다면 자동으로 다음에 이어지는 게시물 데이터를 서버로 요청해야 함
#### 다음에 요청할 페이지 번호를 관리할 수 있어야 함
### 친구 목록 데이터도 배열로 관리함
#### 타임 라인과 마찬가지로 친구를 배열에 추가하거나 배열에서 삭제할 수 있어야 함
### 친구가 수정한 프로필 정보를 반영하기 위해 배열에 있는 친구 데이터를 수정할 수 있는 기능도 필요함
## createReducer 함수에서 immer 패키지를 사용했으므로 리듀서 함수에서 간편하게 상탯값을 수정할 수 있음

# 덕스 패턴
## 리덕스 공식 문서에서는 액션 타입, 액션 생성자 함수, 리듀서 함수를 각각의 파일로 만들어서 설명함
## 리덕스 공식 문서의 방법으로 리덕스 코드를 작성해 본 사람은 알고 있으나 쉬운 작어이 아님
## 간단한 액션을 하나만 추가하려고 하여도 세 개 이상의 파일을 열어서 수정해야 함
## 이 문제를 해결하기 위해, 제안된 방식이 덕스(ducks) 패턴임
### 이 패턴이 오리와 어떤 연관 관계가 있는지 모르나, 리덕스와 발음이 비슷하여 지어진 것으로 추정됨
## 덕스 패턴의 규칙
### 연관된 액션 타입, 액션 생성자 함수, 리듀서 함수를 하나의 파일을 작성함
### 리듀서 함수는 export default 키워드로 내보냄
### 액션 생성자 함수는 export 키워드로 내보냄
### 액션 타입은 접두사와 액션 이름을 조합하여 만듬
## 대부분의 경우, 덕스 패턴으로 리덕스 코드를 작성하는 것이 효율적이며, 특정 파일의 코ㄷ가 많아지면 굳이 하나의 파일을 고집할 필요는 없음
### redux-thunk 패키지를 이용하여 비동기 코드를 작성하는 경우에는 액션 생성자 코드의 양이 많아짐
#### 이럴 때 리듀서 코드와 액션 코드를 별도의 파일로 분리하는 게 좋음

# 리듀서에서 공통 기능을 분리하면 중복된 코드를 줄일 수 있음

# 리덕스에서 제공하는 combineReducer 함수를 이용하면 상탯값의 깊이가 불필요하게 깊어짐
