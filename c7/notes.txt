# 바벨(babel)과 웹팩(webpack)은 웹 애플리케이션을 제작할 때, 없어서는 안 되는 기반 기술이 되었음
## 리액트 또는 뷰를 기반으로 프로젝트를 구축해주는 create-react-app, next.js, vue-cli, nuxt 등의 도구는 바벨과 웹팩을 기본적으로 포함함

# 도구의 도움을 받아 자동으로 프로젝트를 구축하면 바벨과 웹팩을 모르더라도 간단 웹 애플리케이션을 만들 수 있음
## 리액트와 뷰를 처음 배우는 단계에선 바벨과 웹팩을 몰라도 무관하나, 프로젝트 규모가 커지면 바벨과 웹팩을 외면하기 힘듦
## 제스트(jest)와 같은 테스트 프레임워크를 도입할 때, 스토리북(storybook)과 같이 별도의 빌드 과정이 필요할 대, 서버사이드 렌더링을 위해 서버 측 코드를 빌드해야 하는 경우, 바벨과 웹팩을 이해해야만 하는 순간이 존재함

# 리액트로 개발을 하다보면 개발자 대부분이 바벨 설정으로 인해 애를 먹음
## 바벨을 제대로 이해하지 못하면 인터넷에 떠도는 잘못된 설정을 가져올 수도 있음
### 해당 설정은 잘 돌아갈 수도 있으나, 언젠가 문제가 발생할 우려가 존재함
## 바벨과 폴리필의 관계를 이해하지 못하면 오래된 브라우저에서 에러가 발생하는 코드를 만들 수 있음

# 바벨의 실행 방식은 하기와 같음
## @babel/cli로 실행
## 웹팩에서 babel-loader로 실행
## @babel/core를 직접 실행
## @babel/register로 실행
### @babel/register를 이용하면 노드에서 require 코드가 실행될 때 동적으로 바벨이 실행되도록 할 수 있음
### 리액트를 @babel/register와 함께 사용하는 경우가 많지 않음

# 바벨
## 바벨은 입력과 출력이 모두 자바스크립트 코드인 컴파일러임
## 보통 컴파일러가 고수준의 언어를 저수준의 언어로 변환하는 것과 비교됨
## 초기의 바벨은 ES6 코드를 ES5 코드로 변경해주는 컴파일러였으나, 현재에는 바벨을 이용해서 리액트의 JSX 문법, 타입스크립트와 같은 정적 타입의 언어, 코드 압축, 제안(proposal) 단계에 있는 문법 등을 사용할 수 있음
## 바벨을 사용하기 위해선 하기 명령어를 실행하여 패키지를 설치해야 함
### npm init -y
### npm i @babel/core @babel/cli @babel/plugin-transform-arrow-functions @babel/plugin-transform-template-literals @babel/preset-react
### 바벨을 실행하기 위해선 @babel/core 패키지를 필수로 설치해야 함

# 리액트 프리셋을 이용하여 JSX 문법을 변환할 수 있음
## 템플릿 리터럴 플러그인을 이용하여 템플릿 리터럴 코드를 변환할 수 있음
## 화살표 함수 플러그인을 사용하면 화살표 함수로 변환이 가능함

# @/babel/cli를 사용한 바벨의 실행 방법은 하기와 같음
## 예시) npx babel src/code.js --presets=@babel/preset-react --plugins=@babel/plugin-transform-template-literals,@babel/plugin-transform-arrow-functions
## @babel/cli로 거의 모든 설정값을 표현가능하나, 설정할 내용이 많거나 실행 환경에 따라 설정값이 다른 경우에는 설정 파일을 따로 만드는 게 좋음
## 바벨 6가지는 .babelrc 파일로 설정값을 관리하였으나, 바벨 7부터는 babel.config.js 파일로 관리하는 것을 추천함

# 자바스크립트는 동적이므로, 설정값을 만들 수 있음
## .babelrc.js나 babel.config.js을 만들면 하기와 같이 명령어가 축약됨
### npx babel src/code.js;
### npx babel src/code.js --out-file dist.js // 컴파일 결과 파일 단위 저장
### npx babel src --out-dir dist // 컴파일 결과 폴더 단위 저장

# 웹팩의 babel-loader로 실행하기
## 웹팩을 이용하기 위해 하기 패키지를 설치
### npm install webpack webpack-cli webpack-dev-server babel-loader

# webpack.config.js의 구조는 하기와 같음
## entry : 웹팩으로 번들링(bundling)할 파일을 지정
## output : 번들링된 결과를 저장할 경로와 파일을 지정
## module : 자바스크립트 파일을 babel-loader가 처리하도록 설정하며, babel-loader는 바벨의 설정 파일을 이용하므로 이전에 만들어 놓은 babel.config.js 파일의 내용이 설정값으로 사용됨
## optimization : 웹팩은 기본적으로 자바스크립트 파일을 압축함
# npx webpack 명령어로 웹팩을 실행

# @babel/cli와 babel-loader는 모두 @babel/core를 이용하여 바벨을 실행함

# @babel/core 내 내용은 하기와 같음
## require('@babel/core') : @babel/core 모듈을 가져온다
## fs.readFileSync(filename, 'utf8') : 컴파일할 파일의 내용을 가져온다
## plugins : 바벨 플러그인과 프리셋을 설정한다
## babel.transformSync : transformSync 함수를 호출해서 바벨을 실행한다
## configFile : false : babel.config.js 설정 파일을 사용하지 않도록 함

# @babel/core 모듈을 직접 사용하는 방식은 자유도가 높다는 장점이 존재함
## 하기와 같이 코드를 입력했을 경우
"""
const presets = ['@babel/preset-react'];
const plugins = ['@babel/plugin-transform-template-literals'];

const presets = ['@babel/preset-react'];
const plugins = ['@babel/plugin-transform-arrow-functions'];
"""

# @babel/cli 또는 babel-loader를 이용한다면 바벨을 두 번 실행해야 한다
## @babel/core를 사용하면 바벨을 좀 더 효율적으로 실행할 수 있다
## 바벨은 컴파일할 때 하기 세 단계를 거침
### 파싱(parse) 단계 : 입력된 코드로부터 AST(abstract syntax tree)를 생성함
### 변환(transform) 단계 : AST를 원하는 형태를 변환한다
### 생성(generate) 단계 : AST를 코드로 출력한다

## AST는 코드의 구문(syntax)이 분석된 결과를 담고 있는 구조체다
## 코드가 같다면 AST도 같기 때문에 같은 코드에 대해서 하나의 AST를 만들어놓고 재사용할 수 있다


# 바벨 설정 파일에서 사용할 수 있는 다양한 속성 중에서 extends, env, overrides의 특징은 하기와 같다
## extends 속성을 이용하면 다른 설정 파일을 가져와서 확장할 수 있음
## env 또는 overrides 속성을을 이용하면 환경별 또는 파일별로 다른 설정을 적용할 수 있음
## 위 내용을 실행하기 위해 하기 명령어를 실행함
### mkdir test-babel-config
### cd test-babel-config
### npm init -y
### npm install @babel/core @babel/cli @babel/plugin-transform-arrow-functions @babel/plugin-transform-template-literals @babel/preset-react babel-preset-minify
## extends 속성으로 다른 설정 파일 가져오기
### 먼저 프로젝트 루트에 common 폴더를 만들고 그 밑에 .babelrc 파일을 만듦
#### .babelrc 파일 내 플러그인에 옵션을 설정할 때에는 배열로 ㅁ나들어서 두 번째 자리에 옵션을 넣음
#### 템플릿 리터럴 플러그인에 loose 옵션을 주면 문자열을 연결할 때 concat 메서드를 사용하는 대신 + 연산자를 사용할 수 있음
## extends 속성을 이용해서 다른 파일에 있는 설정을 가져옴
## 가져온 설정에 플러그인을 추가하며, 플러그인 옵션은 현재 파일의 옵션으로 결정됨
### 즉, 기존에 설정한 loose 옵션은 사라짐

## env 속성
### 환경별로 다른 설정을 줄 수 있음
### 프로덕션 환경에서는 압축 프리셋을 사용하도록 설정함 => 앞에서 설정한 리액트 프리셋은 유지되고 압축 프리셋이 추가됨
### process.env.BABEL_ENV | process.env.NODE_ENV || "development"
### set NODE_ENV=production && npx babel ./src/example-env
### NODE_ENV 환경 변수를 설정하지 않으면 기본값 development가 사용됨

## overrides 속성으로 파일별로 설정
### overrides 속성을 이용하면 파일별로 다른 설정을 할 수 있음
### include 옵션으로 대상 폴더 및 파일을 선택하고, exclude 옵션으로 제외할 폴더나 파일을 선택함

# 바벨 설정 파일은 2가지임 
## 모든 자바스크립트 파일에 적용되는 전체 (project-wide) 설정 파일 => babel.config.js = 전체 설정 파일
## 자바스크립트 파일의 경로에 따라 결정되는 지역 (file-relative) 설정 파일 => .babelrc, .babelrc.js 파일과 바벨 설정이 있는 package.json 파일 = 지역 설정 파일

# 화살표 함수와 템플릿 리터럴 플러그인 설정
## package.json, babelrc, babelrc.js 파일을 만날 때가지 부모 폴더로 이동함
### src/service1/.babelrc 파일 => 지역 설정 파일
### 프로젝트 루트의 babel.config.js 파일 => 전체 설정 파일
### 전체 설정 파일과 지역 설정 파일을 병합함

# 자바스크립트의 최신 기능을 모두 사용하면서 오래된 브라우저를 지원하려면 바벨로 코드 문법을 변환하는 동시에 폴리필도 사용해야 함
## 폴리필(polyfill)은 런타임에 기능을 주입하는 것을 의미
## 런타임에 기능이 존재하는지, 검사해서 기능이 없는 경우에만 주입함
## 바벨을 사용하면 최신 자바스크립트 표준에 추가된 모든 기능을 사용할 수 있다고 오해하기 쉬움
### 바벨을 사용하더라도 폴리필에 대한 설정은 별도로 해야 함
## 예시로 ES8에 추가된 String.padStart 메서드는 폴리필을 이용하여 추가할 수 있으나, async await는 폴리필로 추가할 수 없으며, 컴파일 타임에 코드 변환을 해야 함

# core-js는 바벨에서 폴리필을 위해 공식적으로 지원하는 패키지임
## core-js 모듈을 가져오면 해당 모듈의 모든 폴리필이 포함됨
## 낮은 버전의 브라우저에서도 프로미스, Object.values, 배열의 includes 메서드를 사용할 수 있음
## core-js 모듈은 사용법이 간단하지만, 필요하지 않는 폴리필까지 포함되므로, 번들 파일의 크기가 커짐
### 번들 파일의 크기에 민감하지 않는 프로젝트에서 사용하기 좋음
## core-js로부터 직접 필요한 폴리필만 가져오면 번들 파일의 크기를 줄일 수 있음
### core-js 모듈은 폴리필을 추가하는 과정이 번거롭고, 필요한 폴리필을 깜빡하고 포함시키지 않는 실수를 할 수 있음
## 번들 파일의 크기를 최소화할 수 있는 방법이므로, 크기에 민감한 프로젝트에 적합함

# @babel/preset-env 프리셋
## @babel/preset-env 프리셋은 실행 환경에 대한 정보를 설정해주면 자동으로 필요한 기능을 주입해 줌
## babel.config.js 파일에 다음 내용을 입력하면 특정 버전의 브라우저를 위한 플러그인만 포함됨
## targets 속성으로 지원하는 브라우저 정보를 입력함
## 시장 점유율이 0.25% 이상이고, 업데이트가 종료되지 않은 브라우저를 입력함
## 브라우저 정보는 browserlist 라는 패키지의 문법을 사용함
## useBuiltIns 속성은 폴리필과 관련된 설정임 -> useBuiltIns 속성에 entry를 입력하면 지원하는 브라우저에서 필요한 폴리필만 포함시킴
### useBuiltIns 속성에 entry를 입력하면 core-js 모듈을 가져오는 코드는 각 폴리필 모듈을 가져오는 여러 줄의 코드로 변환됨
#### 해당 코드들은 크롬 버전 40에 없는 기능을 위한 것으로 실제로 사용 가능한 기능은 프로미스, Object.values, 배열의 includes 메서드 밖에 없으나 불필요하게 많은 폴리필 코드가 추가됨
### useBuiltIns 속성에 usage를 입력하면 코드에서 사용된 기능의 폴리필만 추가됨
#### usage를 입력할 때는 core-js 모듈을 가져오는 코드가 필요하지 않음
#### 파일과 관련된 폴리필 외에 불필요한 폴리필이 추가되는데 바벨이 코드에서 사용된 변수의 타입을 추론하지 못하기 때문임
#### 바벨 입장에선 보수적으로 폴리필을 추가할 수 밖에 없음

# 자바스크립트는 동적 타입 언어이므로 바벨 입장에서 타입 추론은 어렵다
## 타입스크립트와 같은 정적 타입 언어를 사용하면 이런 문제를 해결할 수 있음

# babel.config.js 파일에서 크롬 버전을 조금씩 올려보면서 바벨을 실행하면 출력된 코드에 포함되는 폴리필의 갯수가 점점 줄어든 것을 알 수 있음
## 번들 파일의 크기를 최적화할 목적이라면 필요한 폴리필을 직접 추가하는 방식이 가장 좋으며, 적당한 번들 파일 크기를 유지하면서 폴리필 추가를 깜박할 수 있다면 @babel/preset-env가 좋음

# 바벨은 프리셋과 플러그인을 누구나 제작가능하도록 API를 제공함

# 바벨은 문자열로 입력되는 코드를 AST(Abstract Syntax Tree)라는 구조체로 만들어서 처리함
## 플러그인에서는 AST를 기반으로 코드를 변경함
## 플러그인을 제작하려면 AST 구조를 알아야 함
### AST의 구조를 이해하는 가장 빠른 방법은 astexplorer 사이트에서 코드를 작성해보고 그 코드로부터 만들어진 AST를 확인하는 것임
*** https://astexplorer.net/
#### AST의 각 노드엔 type 속성이 존재함
#### 변수 선언은 VariableDeclaration 타입임
#### 하나의 문장에서 여러 개의 변수를 선안할 수 있으므로, 배열로 관리됨
#### 선언된 변수를 나타내는 타입은 VariableDeclarator임
#### 개발자가 만들어낸 각종 이름은 Identifier 타입으로 만들어짐
#### 사칙연산은 BinaryExpression 타입으로 만들어짐 => left, right 속성으로 연산에 사용되는 변수나 값이 들어감
## 바벨은 babylon이라는 파서를 이용하여 AST를 만듦

# 바벨 플러그인은 하나의 자바스크립트 파일로 만들 수 있음
## 바벨 플러그인의 기본 구조는 하기와 같음
### type 매개변수를 가진 함수를 내보냄
### types 매개변수를 이용해서 AST 노드를 생성할 수 있음
### types 매개변수는 AST 노드의 타입을 검사하는 용도로 사용됨
### 빈 객체를 반환하면 아무 일도 하지 않음

# 콘솔 로그 코드는 ExpressionStatement 노드로 시작함
## 함수 도는 메서드를 호출하는 코드는 CallExpression 노드로 만들어짐
## 메서드 호출은 CallExpression 노드 내부에서 MemberExpression 노드로 만들어짐
## MemberExpression 노드 내부에 객체와 메서드의 이름 정보가 존재함

# npx babel src/code.js

# 함수를 정의하는 코드는 FunctionDeclation 노드로 만들어짐
## 함수 이름은 id 속성에 들어 있음
## BlockStatement 노드의 body 속성에는 함수의 모든 내부 코드에 대한 노드가 배열로 담겨 있음

# webpack 기본 프로젝트 생성
## mkdir webpack-init
## cd webpack-init
## npm init -y
## npm install webpack webpack-cli

# webpack-cli를 이요하면 CLI에서 웹팩을 실행할 수 있음
## webpack-cli를 사용하지 않고 코드를 통해 직접 실행도 가능하며, create-react-app이나 next.js와 같은 프레임워크에서는 세밀하게 웹팩을 다뤄야 하므로, webpack-cli를 이용하지 않고 코드에서 직접 실행함
## npx webpack --mode=development : webpack.config.js 파일이 없는 경우, 모드 설정을 CLI로 직접해야 됨

# 웹팩을 실행하면 dist 폴더가 만들어지고 그 밑에 main.js 번들 파일이 생성됨
## index.js 모듈과 util.js 모듈이 main.js 번들 파일로 합쳐졌으며, 별다른 설정 없이 웹팩을 실행하면 ./src/index.js 모듈을 입력 받아 ./dis/main.js 번들 파일을 생성함

# webpack.config.js 파일을 설정하면 자동으로 프로젝트 루트의 설정 파일이 이용됨
## production 모드로 생성된 파일의 특징은 하기와 같음
### 번들 파일 전체가 즉시 실행 함수 (IIFE : Immediately Invoked Funciton Expression)로 묶여 있음
### 모듈을 관리하는 웹팩 런타임 코드가 존재하는데, 설정 파일에서 entry 파일을 여러 개 입력하면 각 entry에 의해 생성되는 번들 파일에는 웹팩 런타임 코드가 들어감
### 그 후, 사용자 코드가 들어가며, IIFE 함수의 매개변수로 입력됨
### window, global과 같은 전역 변수를 사용하는지, commonJS, AMD 들의 모듈 시스템을 사용하는지의 여부에 따라 번들 파일의 내용은 달라질 수 있음

# 로더(loader)는 모듈을 입력으로 받아서 원하는 형태로 변환한 후 새로운 모듈을 출력해주는 함수이며, 자바스크립트 파일 뿐만이 아닌 이미지 파일, CSS 파일, CSV 파일 등 모든 파일은 모듈이 될 수 있음
## 대표적 예시로 바벨 로더가 존재하는데 이는 자바스크립트 코드에서 JSX 문법으로 작성된 리액트 코드를 처리하기 위해 필요한 패키지들임

# webpack.config.js에서 babel-loader를 설정하지 않고 웹팩을 실행하면 웹팩이 JSX 문법을 이해하지 못하므로 에러가 발생함

# webpack.config.js에서 로더를 배열로 입력하면 오른쪽 로더부터 실행됨

# style-loader는 css-loader가 생성한 CSS 데이터를 style 태그로 만들어서 HTML head에 삽입함
## style-loader는 번들 파일이 브라우저에서 실행될 때 style 태그를 삽입함
## 번들 파일이 실행되다가 에러가 발생하면 style 태그가 삽입되지 않을 수 있음

# css-loader는 단지 css 모듈을 불러오는 역할이며, 적용하려면 style-loader를 사용하여 실제 화면에 보이는 돔 요소에 적용해야 함

# css-module 기능을 이용하면 스타일 코드를 지역화하는데, 이는 css-loader가 제공하는 기능임
## css-loader는 이 외에도 CSS 코드에서 사용된 @import, url() 등의 처리도 도와줌

# 다른 종류의 파일도 모듈 형태로 호출이 가능함
## JSON 모듈은 웹팩에서 기본적으로 처리해주기 때문에 별도의 로더를 설치하지 않아도 됨
## TXT와 PNG 모듈은 로더 패키지를 설치해야 함
### npm install file-loader raw-loader
#### file-loader는 모듈의 내용을 그대로 복사해서 dist 폴더 밑에 복사본을 생성함
#### 모듈을 사용하는 쪽에는 해당 모듈의 경로를 넘겨줌
#### raw-loader는 모듈의 내용을 그대로 자바스크립트로 가져옴

# 웹팩 실행 후 distr 폴더에 생성된 이미지 파일 이름에는 해시 값이 포함되어 있음
## 이 해시값은 이미지 파일을 수정하는 경우에만 변경되므로, 사용자에게 전달된 이미지 파일은 브라우저의 캐싱 효과를 최대한 활용이 가능함

# 이미지 파일을 번들 파일에 포함시키면 브라우저의 파일 요청 횟수를 줄일 수 있음
## 이 때, 번들 파일 크기가 너무 커지면 자바스크립트가 늦게 실행되므로 작은 이미지 파일만 포함시키는 게 좋음
## url-lodaer를 사용하면 크기가 작은 이미지 파일만 번들 파일에 포함시키는 것이 가능함
### url-loader는 파일 크기가 option 내 limit 옵션 값보다 작은 경우에는 번들 파일에 파일의 내용을 포함시킴
### 만약 파일 크기가 option 내 limit 옵션 값보다 크면 다른 로더가 처리할 수 있도록 fallback 옵션을 제공함
#### fallback 옵션을 입력하지 않으면 기본적으로 file-loader가 처리하도록 되어 있음
#### 브라우저에서 img 태그의 src 속성값을 확인해보면 파일의 경로가 아닌 데이터가 입력되어 있음

# 플러그인은 로더보다 강력한 기능을 가짐
## 로더는 특정 모듈에 대한 처리만 담당하나 플러그인은 웹팩이 실행되는 전체 과정에 개입할 수 있음

# webpack.config.js에서 output 파일 이름에 [chunkhash]를 사용하면 파일의 내용이 수정될 때마다 파일 이름이 변경되도록 할 수 있음

# babel.config.js를 사용하여 바벨 설정을 수행하나, babel-loader에서 직접 바벨 설정도 가능함

# 웹팩을 실행해서 나오는 결과물을 확인하기 위해서는 이전처럼 HTML 파일을 수동으로 작성해야 하는 문제점이 존재함
## 번들 파일 이름에 chunkhash 옵션을 설정하였으므로, 파일 내용이 변경될 때마다 HTML 파일 내용도 수정되어야 함
## 위 작업을 자동으로 하는 플러그인이 존재하는데, html-webpack-plugin임

# clean-webpack-plugin은 웹팩을 실행할 때마다 dist 폴더를 정리하는 역할을 수행함
## 여기서 번들 파일의 내용이 변경될 때마다 파일 이름도 변경되므로 이전에 생성된 번들 파일을 정리하는 용도로 사용함

# DefinePlugin은 모듈 내부에 있는 문자열을 대체해줌
## 웹팩에 내장된 플러그인이므로 별도로 설치할 필요는 없음

# 프로덕션 모드로 웹팩을 실행하면 미리 계산된 결과가 번들 파일에 포함됨

# ProvidePlugin은 import 키워드를 사용해서 자주 사용하는 모듈을 가져오는 게 번거로울 때 용이함
## import React from 'react', import $ from 'jquery' 등
## ProvidePlugin을 사용하면 미리 설정한 모듈을 자동으로 등록함
## 해당 플러그이은 웹팩에 기본으로 포함되어 있어 별도의 설치는 필요하지 않음

# JSX 문법을 사용하면 리액트 모듈을 사용하지 않는 것처럼 보여도 바벨이 JSX 문법을 React.createElement 코드로 변환하므로 리액트 모듈이 필요함
## JSX 문법을 사용하는 파일을 작성하면, 반드시 리액트 모듈을 불러내야 함
## 리액트와 같은 프레임워크에 익숙한 사람은 JQuery가 필요없으나, JQuery에 익숙한 개발자는 JQuery 모듈을 반복적으로 호출함

***웹팩을 사용한 애플리케이션 번들 파일 최적화 및 로더와 플러그인 제작을 통한 웹팩 동작 과정 파악
# 나무 흔들기 (tree shaking)
## 나무 흔들기는 불필요한 코드를 제거해주는 기능임
## 나무를 흔들어서 말라 죽은 잎을 떨어뜨리는 것을 비유해서 명명한 이름임
## 웹팩을 기본적으로 나무 흔들기 기능을 제공함
### 단, 웹팩이 알아서 모든 경우를 잘 처리하면 좋으나, 제대로 동작하지 않는 경우도 존재함
## 나무 흔들기를 잘 이해해야 번들 파일 크기를 최소로 줄일 수 있음

# ESM(ECMASCript Modules) 문법은 자바스크립트 표준 모듈 시스템으로 import나 export 등의 키워드를 사용함

# CommonJS에선 module.exports, require 등의 키워드를 사용하며, 이 문법은 node.js에서 많이 사용됨

# 나무 흔들기는 하기 사항에 대해선 적용되지 않음
## 사용되는 모듈이 ESM(ECMAScript Modules)가 아닌 경우
## 사용하는 쪽에서 ESM이 아닌 다른 모듈 시스템을 사용하는 경우
## 동적 임포트 (Dynamic Import)를 사용하는 경우
## 사용되는 쪽과 사용하는 쪽 모두 ESM 문법을 사용해야 나무 흔들기가 제대로 동작됨

# 동적 임포트를 사용하면 동적으로 모듈을 가져올 수 있지만 나무 흔들기가 동작되지 않음

# 모듈 내부에서 자신의 함수를 호출하는 경우 웹팩이 해당 함수에 대해 나무 흔들기를 진행하지 않음

# 모듈은 최초로 사용될 때 한 번 평가되는데, 이때 전역 변수가 변경됨 
## 이 때, 나무 흔들기 단계에서 특정 함수가 제거되면 이를 참조하는 함수는 의도와 다르게 동작됨
## 웹팩은 모듈이 평가되는 시점에 호출되는 함수를 제거하지 않음

# 외부 패키지에 대해서도 나무 흔들기를 적용함
## 하지만 외부 패키지는 저마다 다양한 방식의 모듈 시스템을 사용하므로 나무 흔들기가 제대로 동작되지 않을 수 있음
## lodash 패키지는 ESM으로 되어 있지 않으므로 나무 흔들기로 코드가 제거되지 않음
### lodash는 각 함수를 별도의 파일로 만들어서 제공함
#### 예시 : import fill from 'lodash/fill'
#### 위처럼 사용하면 fill 함수의 코드만 포함됨
### lodash는 ESM 모듈 시스템을 사용하는 lodash-es 패키지를 별도로 제공함
#### 예시 : import { fill } from 'lodash-es';
#### lodash-es 모듈을 가져오는 경우엔 나무 흔들기가 제대로 적용됨

# 본인이 사용하는 패키지에 적용된 모듈 시스템이 무엇인지, ESM이 아니라면 각 기능을 별도의 파일로 제공하는지 여부를 파악해야 번들 크기를 줄일 수 있음

# 바벨을 사용할 때 주의 사항은 우리가 작성한 코드를 바벨로 컴파일한 이후에도 ESM 문법으로 남아 있어야 함
## ESM 문법으로 컴파일된 코드는 웹팩에서 자체적으로 사용 후 제거되므로 오래된 브라우저에 대한 호환성은 걱정하지 않아도 됨

# 애플리케이션의 전체 코드를 하나의 번들 파일로 만드는 것은 불필요한 코드까지 전송되어 사용자의 요청으로부터 페이지가 렌더링되기까지 오랜 시간이 걸리므로 좋지 않을 수 있음
## 단, 번들 파일을 하나만 만들면 관리 부담이 적어지므로 회사 내부용 애플리케이션에는 좋을 수 있음
## 많은 수의 사용자를 대상으로 하는 서비스인 경우, 응답 시간을 최소화하기 위해 코드 분할을 하는 것이 좋음

# 코드를 분할하는 가장 직관적인 방법은 웹팩의 entry 설정값에 페이지별로 파일을 입력하는 것임
## 이 때, 두 파일 모두 같은 모듈의 내용을 포함하는 경우 비효율적일 수 있음

# 웹팩에서는 코드 분할을 위해 기본적으로 SplitChunksPlugin을 내장하고 있음
## 별도의 패키지를 설치하지 않고 설정 파일을 조금 수정하는 것만으로 코드 분할이 가능함
## optimization의 splitChunks 속성을 이용하면 코드 분할이 가능함
### chunks 속성의 기본값은 동적 임포트만 분할하는 async임
### 해당 속성을 이해하기 위해선 먼저 기본값의 형태를 이해해야 함

# 동적 임포트(dynamic import)는 동적으로 모듈을 가져올 수 있는 기능으로 웹팩에서 동적 임포트를 사용하면 해당 모듈의 코드는 자동으로 분할되며, 오래된 브라우저에서도 잘 동작함
## 참고로 동적 임포트는 자바스크립트 표준이 될 것이 거의 확실한 상황인 stage3임
## import 함수를 사용하면 동적으로 모듈을 가져올 수 있음
## import 함수는 프로미스 객체를 반환하므로 then 메서드로 연결할 수 있음

# 분할된 파일을 prefetch, preload로 빠르게 가져오기
## 특정 함수가 버튼의 이벤트 처리 함수로 사용되면 버튼을 클릭하기 이전에는 모듈을 가져오지 않음
## 위와 같이 꼭 필요할 때만 모듈을 가져오는 것을 게으른 로딩(lazy loading)이라고 함
### 게으른 로딩은 번들 파일의 크기가 큰 경우에는 응답 속도가 느리다는 단점이 존재함
## 웹팩에서는 동적 임포트를 사용할 대 HTML의 prefetch, preload 기능을 활용가능하도록 옵션을 제공함
## prefetch는 가까운 미래에 필요한 파일이라고 브라우저에 미리 통보하는 기능임
### HTML에서 prefetch로 설정된 파일은 브라우저가 바쁘지 않을 때 미리 다운로드되도록 함
### prefetch는 게으른 로딩의 단점 보완이 가능함
## preload는 지금 당장 필요한 파일이라고 브라우저에게 통보하는 기능임
### HTML에서 preload로 설정된 파일은 첫 페이지 로딩 시 즉시 다운로드 됨
### preload를 남발하면 첫 페이지 로딩 속도에 부정적인 영향이 존재하므로 주의해야 함
### preload는 첫 페이지 요청 시 전달된 HTML 태그 안에 미리 설정되어 있어야 하므로 웹팩이 지원하지 못하므로 preload 설정이 HTML 코드 내 반영되지 않음

# 로더는 모듈을 입력으로 받아서 원하는 형태로 변경 후 자바스크립트 코드를 반환함
## 로더가 자바스크립트 코드를 반환하므로 웹팩은 CSS, PNG, CSV 확장자를 갖는 모듈도 처리할 수 있음
## 여러 로더가 협력 관계에 있을 때는 중간 과정에 처리되는 css-loader 처럼 자바스크립트가 아닌 다른 형태의 데이터를 반환할 수도 있음
## 하지만 style-loader처럼 가장 마지막에 처리되는 로더는 항상 자바스크립트 코드를 반환함

# 플러그인은 웹팩의 처리 과정을 이해해야 작성이 가능하므로 로더보다 작성이 까다로움
## DefinePlugin처럼 플러그인은 모듈의 내용도 수정할 수 있기 때문에 로더가 할 수 있는 거의 모든 일을 할 수 있음
## 플러그인을 제대로 이해하고 작성하면 매우 강력한 도구가 될 수 있음

# 플러그인에 대한 정보
## 플러그인은 클래스로 정의할 수 있음
## 설정 파일에서 입력한 옵션이 생성자의 매개변수로 넘어옴
## apply 메서드에서는 웹팩의 각 처리 단계에서 호출될 콜백 함수를 등록할 수 있음
### 콜백 함수를 등록할 수 있는 처리 단계가 무수히 많기 대문에 플러그인으로 할 수 있는 일도 그만큼 다양함
## 웹팩의 실행이 완료되었을 때 호출되는 콜백 함수를 등록함
## compilation.assets에는 웹팩에 생성할 파일의 목록이 들어있음
