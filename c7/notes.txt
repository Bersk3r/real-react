# 바벨(babel)과 웹팩(webpack)은 웹 애플리케이션을 제작할 때, 없어서는 안 되는 기반 기술이 되었음
## 리액트 또는 뷰를 기반으로 프로젝트를 구축해주는 create-react-app, next.js, vue-cli, nuxt 등의 도구는 바벨과 웹팩을 기본적으로 포함함

# 도구의 도움을 받아 자동으로 프로젝트를 구축하면 바벨과 웹팩을 모르더라도 간단 웹 애플리케이션을 만들 수 있음
## 리액트와 뷰를 처음 배우는 단계에선 바벨과 웹팩을 몰라도 무관하나, 프로젝트 규모가 커지면 바벨과 웹팩을 외면하기 힘듦
## 제스트(jest)와 같은 테스트 프레임워크를 도입할 때, 스토리북(storybook)과 같이 별도의 빌드 과정이 필요할 대, 서버사이드 렌더링을 위해 서버 측 코드를 빌드해야 하는 경우, 바벨과 웹팩을 이해해야만 하는 순간이 존재함

# 리액트로 개발을 하다보면 개발자 대부분이 바벨 설정으로 인해 애를 먹음
## 바벨을 제대로 이해하지 못하면 인터넷에 떠도는 잘못된 설정을 가져올 수도 있음
### 해당 설정은 잘 돌아갈 수도 있으나, 언젠가 문제가 발생할 우려가 존재함
## 바벨과 폴리필의 관계를 이해하지 못하면 오래된 브라우저에서 에러가 발생하는 코드를 만들 수 있음

# 바벨의 실행 방식은 하기와 같음
## @babel/cli로 실행
## 웹팩에서 babel-loader로 실행
## @babel/core를 직접 실행
## @babel/register로 실행
### @babel/register를 이용하면 노드에서 require 코드가 실행될 때 동적으로 바벨이 실행되도록 할 수 있음
### 리액트를 @babel/register와 함께 사용하는 경우가 많지 않음

# 바벨
## 바벨은 입력과 출력이 모두 자바스크립트 코드인 컴파일러임
## 보통 컴파일러가 고수준의 언어를 저수준의 언어로 변환하는 것과 비교됨
## 초기의 바벨은 ES6 코드를 ES5 코드로 변경해주는 컴파일러였으나, 현재에는 바벨을 이용해서 리액트의 JSX 문법, 타입스크립트와 같은 정적 타입의 언어, 코드 압축, 제안(proposal) 단계에 있는 문법 등을 사용할 수 있음
## 바벨을 사용하기 위해선 하기 명령어를 실행하여 패키지를 설치해야 함
### npm init -y
### npm i @babel/core @babel/cli @babel/plugin-transform-arrow-functions @babel/plugin-transform-template-literals @babel/preset-react
### 바벨을 실행하기 위해선 @babel/core 패키지를 필수로 설치해야 함

# 리액트 프리셋을 이용하여 JSX 문법을 변환할 수 있음
## 템플릿 리터럴 플러그인을 이용하여 템플릿 리터럴 코드를 변환할 수 있음
## 화살표 함수 플러그인을 사용하면 화살표 함수로 변환이 가능함

# @/babel/cli를 사용한 바벨의 실행 방법은 하기와 같음
## 예시) npx babel src/code.js --presets=@babel/preset-react --plugins=@babel/plugin-transform-template-literals,@babel/plugin-transform-arrow-functions
## @babel/cli로 거의 모든 설정값을 표현가능하나, 설정할 내용이 많거나 실행 환경에 따라 설정값이 다른 경우에는 설정 파일을 따로 만드는 게 좋음
## 바벨 6가지는 .babelrc 파일로 설정값을 관리하였으나, 바벨 7부터는 babel.config.js 파일로 관리하는 것을 추천함

# 자바스크립트는 동적이므로, 설정값을 만들 수 있음
## .babelrc.js나 babel.config.js을 만들면 하기와 같이 명령어가 축약됨
### npx babel src/code.js;
### npx babel src/code.js --out-file dist.js // 컴파일 결과 파일 단위 저장
### npx babel src --out-dir dist // 컴파일 결과 폴더 단위 저장

# 웹팩의 babel-loader로 실행하기
## 웹팩을 이용하기 위해 하기 패키지를 설치
### npm install webpack webpack-cli webpack-dev-server babel-loader

# webpack.config.js의 구조는 하기와 같음
## entry : 웹팩으로 번들링(bundling)할 파일을 지정
## output : 번들링된 결과를 저장할 경로와 파일을 지정
## module : 자바스크립트 파일을 babel-loader가 처리하도록 설정하며, babel-loader는 바벨의 설정 파일을 이용하므로 이전에 만들어 놓은 babel.config.js 파일의 내용이 설정값으로 사용됨
## optimization : 웹팩은 기본적으로 자바스크립트 파일을 압축함
# npx webpack 명령어로 웹팩을 실행

# @babel/cli와 babel-loader는 모두 @babel/core를 이용하여 바벨을 실행함

# @babel/core 내 내용은 하기와 같음
## require('@babel/core') : @babel/core 모듈을 가져온다
## fs.readFileSync(filename, 'utf8') : 컴파일할 파일의 내용을 가져온다
## plugins : 바벨 플러그인과 프리셋을 설정한다
## babel.transformSync : transformSync 함수를 호출해서 바벨을 실행한다
## configFile : false : babel.config.js 설정 파일을 사용하지 않도록 함

# @babel/core 모듈을 직접 사용하는 방식은 자유도가 높다는 장점이 존재함
## 하기와 같이 코드를 입력했을 경우
"""
const presets = ['@babel/preset-react'];
const plugins = ['@babel/plugin-transform-template-literals'];

const presets = ['@babel/preset-react'];
const plugins = ['@babel/plugin-transform-arrow-functions'];
"""

# @babel/cli 또는 babel-loader를 이용한다면 바벨을 두 번 실행해야 한다
## @babel/core를 사용하면 바벨을 좀 더 효율적으로 실행할 수 있다
## 바벨은 컴파일할 때 하기 세 단계를 거침
### 파싱(parse) 단계 : 입력된 코드로부터 AST(abstract syntax tree)를 생성함
### 변환(transform) 단계 : AST를 원하는 형태를 변환한다
### 생성(generate) 단계 : AST를 코드로 출력한다

## AST는 코드의 구문(syntax)이 분석된 결과를 담고 있는 구조체다
## 코드가 같다면 AST도 같기 때문에 같은 코드에 대해서 하나의 AST를 만들어놓고 재사용할 수 있다


# 바벨 설정 파일에서 사용할 수 있는 다양한 속성 중에서 extends, env, overrides의 특징은 하기와 같다
## extends 속성을 이용하면 다른 설정 파일을 가져와서 확장할 수 있음
## env 또는 overrides 속성을을 이용하면 환경별 또는 파일별로 다른 설정을 적용할 수 있음
## 위 내용을 실행하기 위해 하기 명령어를 실행함
### mkdir test-babel-config
### cd test-babel-config
### npm init -y
### npm install @babel/core @babel/cli @babel/plugin-transform-arrow-functions @babel/plugin-transform-template-literals @babel/preset-react babel-preset-minify
## extends 속성으로 다른 설정 파일 가져오기
### 먼저 프로젝트 루트에 common 폴더를 만들고 그 밑에 .babelrc 파일을 만듦
#### .babelrc 파일 내 플러그인에 옵션을 설정할 때에는 배열로 ㅁ나들어서 두 번째 자리에 옵션을 넣음
#### 템플릿 리터럴 플러그인에 loose 옵션을 주면 문자열을 연결할 때 concat 메서드를 사용하는 대신 + 연산자를 사용할 수 있음
## extends 속성을 이용해서 다른 파일에 있는 설정을 가져옴
## 가져온 설정에 플러그인을 추가하며, 플러그인 옵션은 현재 파일의 옵션으로 결정됨
### 즉, 기존에 설정한 loose 옵션은 사라짐

## env 속성
### 환경별로 다른 설정을 줄 수 있음
### 프로덕션 환경에서는 압축 프리셋을 사용하도록 설정함 => 앞에서 설정한 리액트 프리셋은 유지되고 압축 프리셋이 추가됨
### process.env.BABEL_ENV | process.env.NODE_ENV || "development"
### set NODE_ENV=production && npx babel ./src/example-env
### NODE_ENV 환경 변수를 설정하지 않으면 기본값 development가 사용됨

## overrides 속성으로 파일별로 설정
### overrides 속성을 이용하면 파일별로 다른 설정을 할 수 있음
### include 옵션으로 대상 폴더 및 파일을 선택하고, exclude 옵션으로 제외할 폴더나 파일을 선택함

# 바벨 설정 파일은 2가지임 
## 모든 자바스크립트 파일에 적용되는 전체 (project-wide) 설정 파일 => babel.config.js = 전체 설정 파일
## 자바스크립트 파일의 경로에 따라 결정되는 지역 (file-relative) 설정 파일 => .babelrc, .babelrc.js 파일과 바벨 설정이 있는 package.json 파일 = 지역 설정 파일

# 화살표 함수와 템플릿 리터럴 플러그인 설정
## package.json, babelrc, babelrc.js 파일을 만날 때가지 부모 폴더로 이동함
### src/service1/.babelrc 파일 => 지역 설정 파일
### 프로젝트 루트의 babel.config.js 파일 => 전체 설정 파일
### 전체 설정 파일과 지역 설정 파일을 병합함

# 자바스크립트의 최신 기능을 모두 사용하면서 오래된 브라우저를 지원하려면 바벨로 코드 문법을 변환하는 동시에 폴리필도 사용해야 함
## 폴리필(polyfill)은 런타임에 기능을 주입하는 것을 의미
## 런타임에 기능이 존재하는지, 검사해서 기능이 없는 경우에만 주입함
## 바벨을 사용하면 최신 자바스크립트 표준에 추가된 모든 기능을 사용할 수 있다고 오해하기 쉬움
### 바벨을 사용하더라도 폴리필에 대한 설정은 별도로 해야 함
## 예시로 ES8에 추가된 String.padStart 메서드는 폴리필을 이용하여 추가할 수 있으나, async await는 폴리필로 추가할 수 없으며, 컴파일 타임에 코드 변환을 해야 함

# core-js는 바벨에서 폴리필을 위해 공식적으로 지원하는 패키지임
## core-js 모듈을 가져오면 해당 모듈의 모든 폴리필이 포함됨
## 낮은 버전의 브라우저에서도 프로미스, Object.values, 배열의 includes 메서드를 사용할 수 있음
## core-js 모듈은 사용법이 간단하지만, 필요하지 않는 폴리필까지 포함되므로, 번들 파일의 크기가 커짐
### 번들 파일의 크기에 민감하지 않는 프로젝트에서 사용하기 좋음
## core-js로부터 직접 필요한 폴리필만 가져오면 번들 파일의 크기를 줄일 수 있음
### core-js 모듈은 폴리필을 추가하는 과정이 번거롭고, 필요한 폴리필을 깜빡하고 포함시키지 않는 실수를 할 수 있음
## 번들 파일의 크기를 최소화할 수 있는 방법이므로, 크기에 민감한 프로젝트에 적합함

# @babel/preset-env 프리셋
## @babel/preset-env 프리셋은 실행 환경에 대한 정보를 설정해주면 자동으로 필요한 기능을 주입해 줌
## babel.config.js 파일에 다음 내용을 입력하면 특정 버전의 브라우저를 위한 플러그인만 포함됨
## targets 속성으로 지원하는 브라우저 정보를 입력함
## 시장 점유율이 0.25% 이상이고, 업데이트가 종료되지 않은 브라우저를 입력함
## 브라우저 정보는 browserlist 라는 패키지의 문법을 사용함
## useBuiltIns 속성은 폴리필과 관련된 설정임 -> useBuiltIns 속성에 entry를 입력하면 지원하는 브라우저에서 필요한 폴리필만 포함시킴
### useBuiltIns 속성에 entry를 입력하면 core-js 모듈을 가져오는 코드는 각 폴리필 모듈을 가져오는 여러 줄의 코드로 변환됨
#### 해당 코드들은 크롬 버전 40에 없는 기능을 위한 것으로 실제로 사용 가능한 기능은 프로미스, Object.values, 배열의 includes 메서드 밖에 없으나 불필요하게 많은 폴리필 코드가 추가됨
### useBuiltIns 속성에 usage를 입력하면 코드에서 사용된 기능의 폴리필만 추가됨
#### usage를 입력할 때는 core-js 모듈을 가져오는 코드가 필요하지 않음
#### 파일과 관련된 폴리필 외에 불필요한 폴리필이 추가되는데 바벨이 코드에서 사용된 변수의 타입을 추론하지 못하기 때문임
#### 바벨 입장에선 보수적으로 폴리필을 추가할 수 밖에 없음

# 자바스크립트는 동적 타입 언어이므로 바벨 입장에서 타입 추론은 어렵다
## 타입스크립트와 같은 정적 타입 언어를 사용하면 이런 문제를 해결할 수 있음

# babel.config.js 파일에서 크롬 버전을 조금씩 올려보면서 바벨을 실행하면 출력된 코드에 포함되는 폴리필의 갯수가 점점 줄어든 것을 알 수 있음
## 번들 파일의 크기를 최적화할 목적이라면 필요한 폴리필을 직접 추가하는 방식이 가장 좋으며, 적당한 번들 파일 크기를 유지하면서 폴리필 추가를 깜박할 수 있다면 @babel/preset-env가 좋음

# 바벨은 프리셋과 플러그인을 누구나 제작가능하도록 API를 제공함

# 바벨은 문자열로 입력되는 코드를 AST(Abstract Syntax Tree)라는 구조체로 만들어서 처리함
## 플러그인에서는 AST를 기반으로 코드를 변경함
## 플러그인을 제작하려면 AST 구조를 알아야 함
### AST의 구조를 이해하는 가장 빠른 방법은 astexplorer 사이트에서 코드를 작성해보고 그 코드로부터 만들어진 AST를 확인하는 것임
*** https://astexplorer.net/
#### AST의 각 노드엔 type 속성이 존재함
#### 변수 선언은 VariableDeclaration 타입임
#### 하나의 문장에서 여러 개의 변수를 선안할 수 있으므로, 배열로 관리됨
#### 선언된 변수를 나타내는 타입은 VariableDeclarator임
#### 개발자가 만들어낸 각종 이름은 Identifier 타입으로 만들어짐
#### 사칙연산은 BinaryExpression 타입으로 만들어짐 => left, right 속성으로 연산에 사용되는 변수나 값이 들어감
## 바벨은 babylon이라는 파서를 이용하여 AST를 만듦

# 바벨 플러그인은 하나의 자바스크립트 파일로 만들 수 있음
## 바벨 플러그인의 기본 구조는 하기와 같음
### type 매개변수를 가진 함수를 내보냄
### types 매개변수를 이용해서 AST 노드를 생성할 수 있음
### types 매개변수는 AST 노드의 타입을 검사하는 용도로 사용됨
### 빈 객체를 반환하면 아무 일도 하지 않음

# 콘솔 로그 코드는 ExpressionStatement 노드로 시작함
## 함수 도는 메서드를 호출하는 코드는 CallExpression 노드로 만들어짐
## 메서드 호출은 CallExpression 노드 내부에서 MemberExpression 노드로 만들어짐
## MemberExpression 노드 내부에 객체와 메서드의 이름 정보가 존재함

# npx babel src/code.js

# 함수를 정의하는 코드는 FunctionDeclation 노드로 만들어짐
## 함수 이름은 id 속성에 들어 있음
## BlockStatement 노드의 body 속성에는 함수의 모든 내부 코드에 대한 노드가 배열로 담겨 있음