# 서버 사이드 렌더링 (server side rendering)은 서버에서 리액트 코드를 실행해서 렌더링하는 것을 의미함
##  서버 사이드 렌더링은 검색 엔진 (Search Engine Optimization, SEO)를 하기 위함과 빠른 첫 페이지 렌더링이 중요하기 때문임
### 많은 수의 사용자를 대상으로 하는 사이트라면 검색 엔진 최적화를 위해서 서버 사이드 렌더링은 필수임
### 구글을 제외한 다른 검색 엔진에서는 자바스크립트를 실행하지 않으므로, 클라이언트 렌더링만 하는 사이트는 내용이 없는 사이트와 동일시 처리됨
#### 구글도 서버 사이드 렌더링을 하는 사이트에 더 높은 점수를 부여함
## 서버 사이드 렌더링을 하면 사용자가 요청한 페이지를 빠르게 보여줄 수 있음
### 클라이언트 렌더링만 진행하면 자바스크립트를 실행해야만 화면이 보이므로 저사양 기기를 사용하는 사용자일수록 요청한 페이지가 느리게 보임
### 저사양 기기 사용자나, 네트워크 인프라가 약한 나라에서의 서비스를 고려하면 서버 사이드 렌더링을 진행하는 것이 좋음

# 서버 사이드 렌더링을 진행할 때, 하기 내용이 필요함
## 리액트에서 제공하는 renderToString과 hydrate 함수
## 서버에서 생성된 데이터를 클라이언트로 전달하는 방법
## styled-components로 작성된 스타일이 서버 사이드 렌더링 시 처리 방법
## 서버용 번들 파일 제작

# babel.config.js 파일의 설정은 babel-loader가 실행될 때 적용됨

# url이 file://로 시작하는 경우 pushState 메서드를 호출할 때 에러가 발상함
## 서버를 띄우는 방식을 이용하면 이는 해결됨

# 첫 요청에 대한 응답으로 돌아오는 HTML에는 버튼이나 문구를 표현하는 돔 요소가 존재하지 않으며, 브라우저 개발자 모드 내 네트워크 메뉴를 통해 쉽게 확인 가능함
## 버튼이나 문구의 돔 요소는 자바스크립트가 실행되면서 추가되며 브라우저 옵션에서 자바스크립트 실행을 허용하지 않고 실행하면 화면에는 아무 것도 보이지 않는 것을 확인할 수 있음
### 서버 사이드 렌더링을 구현하면 브라우저가 자바스크립트를 실행하지 않아도 화면의 내용은 확인할 수 있음

# 리액트 내에서 서버 사이드 렌더링을 위해 하기 함수들을 제공함
## renderToString
## renderToNodeStream
## renderToStaticMarkup
## rednerToStaticNodeStream
## renderToStaticMarkup과 rednerToStaticNodeStream 함수는 정적 페이지를 렌더링할 때 사용됨
## 최초 렌더링 이후에도 계속해서 상태 변화에 따라 화면을 갱신해야 하면 renderToString 또는 renderToNodeStream 함수를 사용해야 함

# 서버 사이드 렌더링에 필용한 패키지는 하기와 같음
## npm install express @babel/cli @babel/plugin-transform-modules-commonjs
### 웹 서버를 띄우기 위해 express 패키지를 설치함
### @babel/cli 패키지는 서버에서 사용될 자바스크립트 파일을 컴파일 할 때 사용됨
### 서버에서도 리액트의 JSX 문법으로 작성된 자바스크립트를 실행해야 하므로 바벨이 필요함
### ESM으로 작성된 모듈 시스템을 commonJS로 변경하기 위해 @babel/plugin-transform-modules-commonjs 패키지를 설치함
#### 서버에서는 노드 환경에서 자바스크립트를 실행하기 때문에 commonJS 모듈 시스템이 필요함

# react-dom/server 밑에 서버에서 사용되는 기능이 주요 존재함

# express 객체인 app 변수를 이용하여 미들웨어와 url 경로 설정이 가능함

# 서버 사이드 렌더링 시, 웹팩 빌드 후 생성된 특정 파일의 정보를 가져와, 이를 기반으로 새로운 HTML을 생성함
## 웹팩으로 빌드한 자바스크립트 파일이 이 코드에 의해 서비스됨

# renderToString 함수는 문자열을 반환함

# 서버와 클라이언트에 필요한 바벨 설정은 하기와 같음
## 클라이언트 : 바벨 프리셋(@babel/preset-react, @babel/preset-env), 바벨 플러그인 X
## 서버 : 바벨 프리셋(@babel/preset-react), 바벨 플러그인 (@babel/plugin-transform-modules-commonjs)
## @babel/preset-env는 주로 오래된 브라우저를 지우너하기 위한 용도로 사용됨
## 오래된 노드 버전을 사용하기 아니면 불필요하므로, 서버 측 바벨 설정에 포함하지 않음
## @babel/plugin-transform-modules-commonjs는 서버에서 실행하는 노드를 위해 필요함

# 웹팩 설정 파일에서는 HTML에 추가되는 번들 파일의 경로와 바벨 설정 파일의 경로를 수정해야 함
## publicPath 설정은 html-webpack-plugin이 HTML 생성 시 HTML 내부 리소스 파일의 경로를 만들 때 사용됨
### publicPath 설정 없이 생성된 HTML 파일은 브라우저에서 바로 실행하면 문제가 없으나 서버사이드 렌더링을 할 때는 문제가 존재함
### 이전에 server.js 파일에서 url이 /dist로 시작하는 경우에만 dist 폴더에 있는 파일을 서비스하도록 서정했으므로 publicPath도 같게 설정함
## 웹팩은 클라이언트 코드에 대해서만 실행할 예정으로 babel-loader가 클라이언트 설정으로 실행되도록 함

# 서버 측 코드는 @babel/cli를 이용해서 바벨만 실행하고, 클라이언트 측 코드는 웹팩을 실행함
## 앞으로 코드를 빌드하고 웹 서버를 띄우는 작업을 자주해야 하므로, package.json 내 script 옵션에 하기 내용을 추가함
### "build-server": "babel src --out-dir dist-server --config-file ./.babelrc.server.js" => 서버 측 코드를 빌드함, src 폴더 밑에 있는 모든 파일을 babelrc.server.js 설정으로 컴파일을 진행함
### "build": "npm run build-server && webpack", // 서버와 클라이언트 코드를 모두 빌드함, 클라이언트 측 빌드는 웹팩을 이용함
### "start": "node dist-server/server.js", // express 웹 서버를 띄우며 해당 명령은 빌드 후에 사용해야 함

# 서버 사이드 렌더링을 하면 이미 돔 요소가 만들어진 상태이므로 클라이언트 측에서 또다시 렌더링할 필요는 없음
## 하지만 각 돔 요소에 필요한 이벤트 처리 함수를 연결해야 함
### 이벤트 처리 함수를 연결하지 않으면 화면은 잘 보이나 사용자가 버튼을 눌러도 반응하지 않음
## 리액트에서 제공하는 hydrate 함수는 서버사이드 렌더링의 결과로 만들어진 돔 요소에 필요한 이벤트 처리 함수를 제공함

# 서버에서 렌더링할 때 사용한 데이터를 클라이언트도 알아야 일관성 있게 화면을 갱신할 수 있음
## HTML에 데이터를 넣기 위해선 서버는 __DATA_FROM_SERVER__ 부분에 데이터를 채워서 전달하고, 클라이언트는 window.__INITIAL_DATA__를 통해서 서버의 데이터를 받음
### 웹 서버 코드에서는 서버의 데이터를 HTML에서 삽입해야 함
#### 문자열로 된 주솟값을 구조체로 변환함 -> parsedUrl 변수는 url의 경로와 쿼리 파라미터 등의 정보를 가지고 있음

# 리덕스를 사용하는 프로젝트에서는 리덕스의 상탯값을 window.__INITIAL_DATA__로 전달하여 사용할 수 있음

# 리액트에서 스타일을 적용하는 방식은 다양하며, 전통적인 방식으로 CSS 파일을 별도로 작성 후 HTML 파일에 연결하면 서버사이드 렌더링 시 특별히 고민할 것은 없음
## 하지만 css-module이나 css-in-js 방식으로 작성한다면 서버사이드 렌더링 시 추가 작업을 진행해야 함
## 둘 다 자바스크립트 코드가 실행되면서 스타일 코드가 돔에 삽입되는 방식이므로 서버에는 돔이 없어 별도의 작업을 하지 않으면 서버사이드 렌더링 시, 스타일 정보가 HTML에 포함되지 않음

# styled-components로 스타일 적용
## npm install styled-components
## 스타일이 잘 적용된 것처럼 보여도 HTML에는 스타일 코드가 존재하지 않으며, 자바스크립트가 실행되지 않으면 스타일이 적용되지 않고, 검색 엔진에서는 스타일이 적용되지 않은 화면이 전달됨
### 먼저, 스타일을 추출하는 데 사용할 객체를 생성하고 collectStyles 메서드에 리액트 요소를 입력하면 스타일 정보를 수집하기 위한 코드가 리객트 요소에 삽입됨
#### 이 때, 실제 스타일 정보는 renderToString 함수의 호출이 끝나야 수집이 가능함
### getStyleTags 메서드를 호출하면 스타일 정보를 추출할 수 있음
### 스타일 정보가 HTML에 포함되어 전달되므로 사용자는 자바스크립트가 실행되지 않더라도 빠르게 스타일이 적용된 화면을 볼 수 있음

# 웹팩에서는 자바스크립트 파일 뿐만이 아닌 모든 파일이 모듈이 될 수 있음
## 이미지 파일은 대개 file-loader 또는 url-loader를 이용하여 처리함
### file-loader에게 전달된 리소스 파일은 output 설정에 지정된 폴더로 복사되며, 자바스크립트 코드에서는 복사된 파일의 경로가 반환됨
### 파일의 경로는 클라이언트와 서버가 모두 같은 정보를 공유해야 함 -> 그렇지 않으면 서버사이드 렌더링 결과가 클라이언트의 렌더링 결과와 달라서 문제가 됨
### 클라이언트 코드에서 file-loader로 처리된 리소스는 서버 코드에서 file-loader로 처리해야 하며, 서버 코드에서 file-loader를 실행하려면 서버 코드도 웹팩으로 번들링해야 함

# 서버 코드를 번들링할 때는 node_modules 폴더 밑에 있는 모듈까지 하나의 번들 파일로 만들 필요가 없음
## 서버 코드는 언제든지 node_modules 폴더 밑에 있는 모듈을 가져와서 사용할 수 있기 때문임
## webpack-node-externals 모듈은 node_modules 폴더 밑에 있는 모듈을 번들 파일에서 제외시켜 주는 역할을 함
## 웹팩 설정 파일에서 배열을 내보내면 배열의 각 아이템 갯수만큼 웹팩이 실행됨 -> 이 경우, 클라이언트 코드가 먼저 번들링되고, 서버 코드가 그 다음에 번들링됨

# 웹팩에 대한 대략적인 설정 내용은 하기와
## 클라이언트는 브라우저의 캐싱 효과 때문에 chunkhash를 사용하지만 서버는 필요 없음
## target 속성에 node를 입력해서 웹팩에 서버 코드를 번들링하는 것이라 알려줄 수 있음
### 웹팩은 node가 입력되면 노드에 특화된 번들링 과정을 거치며, fs, path 모듈과 같이 노드에 내장된 모듈을 번들 파일에 포함시키지 않음
## 서버 코드를 번들링할 때는 node_modules 폴더 밑에 있는 모듈을 버들 파일에 포함시키지 않도록 함

# 서버사이드 렌더링은 서버 리소스를 많이 사용하는데, 특히 렌더링 연산에 CPU가 많이 이용됨
## 한순간에 트래픽이 몰리면 모든 요청을 처리할 수 없음
## 높은 트래픽에 대응하는 방법은 여러가지이며, 프로젝트 상황에 맞게 적절한 방법을 사용해야 함

# 서버가 사용자의 요청에 가장 빠르게 응답하는 방법은 서버사이드 렌더링을 하지 않는 것임
## 평상시에는 서버사이드 렌더링을 진행하다가 서버 부하가 일정 수준을 넘어가면 서버사이드 렌더링을 포기하고 클라이언트 측에서만 렌더링하는 것도 한 가지 방법임
### 하지만 검색 엔진 최적화가 중요한 사이트라면 검색 엔진의 요청은 이런 상황이라도 서버사이드 렌더링을 하는 게 좋음
## 데이터 의존성이 낮은 페이지는 서버사이드 렌더링을 일부만 하는 방식으로 성능 문제를 해결할 수 있음
## 데이터 의존성이 전혀 없는 페이지는 빌드 시 미리 렌더링할 수 있음
## 사용자가 요청하면 단순히 정적 페이지를 서비스하면 되므로 서버 리소스를 절약할 수 있음
## 데이터에 의존성이 있더라도 그 범위가 작으면 해당하는 영역만 클라이언트 측에서 렌더링하도록 설계하면 됨
### 예시로 한쪽 모서리에 사용자 이름을 보여 주는 부분만 데이터에 의존적이면 그 부분만 클라이언트 측에서 렌더링하고 나머지 부분은 빌드 시 미리 렌더링이 가능함
#### 사용자 이름이 서버사이드 렌더링 시 존재하면 home 페이지는 사용자마다 다르므로 미리 렌더링이 어려움
#### 서버사이드 렌더링 시에는 사용자 이름 없이 렌더링하고, 클라이언트에서는 마운트 이후에 사용자 이름을 API로 받아오면 됨

# 데이터에 많이 의존적인 페이지는 정적 페이지를 미리 렌더링하는 방식을 사용할 수 없음
## 하지만 데이터가 자주 변하지 않는 페이지라면 서버사이드 렌더링 결과를 캐싱하여 사용할 수 있음
## 렌더링 결과를 1분만 캐싱해도 서버 부하를 크게 줄일 수 있음
### 1분 동안 수십만 페이지 뷰가 발생하더라도 단 한번만 서버사이드 렌더링을 하면 됨

# 제한된 메모리 안에 캐싱 데이터를 저장하려면 지울 데이터를 결정하는 알고리즘이 필요함
## npm install lru-cache
## lru-cache 패키지는 정해진 최대 캐시 갯수를 초고하면 LRU(Least Recently Used) 알고리즘에 따라 가장 오랫동안 사용되지 않은 캐시를 제거함

# 리액트는 서버사이드 렌더링을 위해 renderToString 함수 외에 renderToNodeStream 함수도 제공하고 있음
## renderToString 함수는 모든 렌더링 과정이 끝나야 문자열로 된 결괏값을 반환하지만, renderToNodeStream 함수는 호출 즉시 노드의 스트림 객체를 반환함
## renderToNodeStream 함수를 이용하면 렌더링 데이터를 빠르게 전달할 수 있다는 장점이 존재함
### 렌더링하려는 페이지가 아무리 복잡하더라도 첫 번재 청크가 준비되면 바로 전송을 시작하기 때문임

# 스트림은 배열이나 문자열과 같은 데이터 컬렉션이며, 크기가 큰 데이터를 다룰 때 유용함
## 스트림은 데이터를 청크 단위로 쪼개서 전달하므로 데이터가 완전히 준비되지 않아도 전송을 시작할 수 있음
## 스트림을 이용한 방법은 메모리를 효율적으로 사용할 뿐만이 아닌 첫 번째 청크가 준비되면 바로 전송을 시작하므로 데이터를 빠르게 전송할 수 있음
## 읽기와 쓰기 모두 가능한 스트림(duplex stream) 객체도 존재하며, 읽기와 쓰기가 모두 가능한 스트림은 세 개 이상의 스트림을 연결할 때 사용됨

# 스트림 방식에서 캐싱을 구현하기 위해선 스트림으로 전송되는 청크 데이터에 접근할 수 있어야 함
## 두 스트림 사이에 직접 구현한 스트림을 넣어야만 가능해짐

# 효율적인 개발을 위해서 서버사이드 렌더링을 구현할 수 있는 더 많은 기능이 필요함
## 이를 해결할 수단이 Next.js임

# 넥스트와 create-react-app은 리액트를 기반으로 개발 환경을 구축한다는 점에서 비슷하나 create-react-app은 클라이언트 렌더링만 하는 반면, 넥스트는 서버사이드 렌더링에 특화된 프레임워크라는 점이 다름
## 서버사이드 렌더링을 해야하는 직접 구축이 어렵다면 넥스트를 추천함
