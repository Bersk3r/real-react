# 서버 사이드 렌더링 (server side rendering)은 서버에서 리액트 코드를 실행해서 렌더링하는 것을 의미함
##  서버 사이드 렌더링은 검색 엔진 (Search Engine Optimization, SEO)를 하기 위함과 빠른 첫 페이지 렌더링이 중요하기 때문임
### 많은 수의 사용자를 대상으로 하는 사이트라면 검색 엔진 최적화를 위해서 서버 사이드 렌더링은 필수임
### 구글을 제외한 다른 검색 엔진에서는 자바스크립트를 실행하지 않으므로, 클라이언트 렌더링만 하는 사이트는 내용이 없는 사이트와 동일시 처리됨
#### 구글도 서버 사이드 렌더링을 하는 사이트에 더 높은 점수를 부여함
## 서버 사이드 렌더링을 하면 사용자가 요청한 페이지를 빠르게 보여줄 수 있음
### 클라이언트 렌더링만 진행하면 자바스크립트를 실행해야만 화면이 보이므로 저사양 기기를 사용하는 사용자일수록 요청한 페이지가 느리게 보임
### 저사양 기기 사용자나, 네트워크 인프라가 약한 나라에서의 서비스를 고려하면 서버 사이드 렌더링을 진행하는 것이 좋음

# 서버 사이드 렌더링을 진행할 때, 하기 내용이 필요함
## 리액트에서 제공하는 renderToString과 hydrate 함수
## 서버에서 생성된 데이터를 클라이언트로 전달하는 방법
## styled-components로 작성된 스타일이 서버 사이드 렌더링 시 처리 방법
## 서버용 번들 파일 제작

# babel.config.js 파일의 설정은 babel-loader가 실행될 때 적용됨

# url이 file://로 시작하는 경우 pushState 메서드를 호출할 때 에러가 발상함
## 서버를 띄우는 방식을 이용하면 이는 해결됨

# 첫 요청에 대한 응답으로 돌아오는 HTML에는 버튼이나 문구를 표현하는 돔 요소가 존재하지 않으며, 브라우저 개발자 모드 내 네트워크 메뉴를 통해 쉽게 확인 가능함
## 버튼이나 문구의 돔 요소는 자바스크립트가 실행되면서 추가되며 브라우저 옵션에서 자바스크립트 실행을 허용하지 않고 실행하면 화면에는 아무 것도 보이지 않는 것을 확인할 수 있음
### 서버 사이드 렌더링을 구현하면 브라우저가 자바스크립트를 실행하지 않아도 화면의 내용은 확인할 수 있음

# 리액트 내에서 서버 사이드 렌더링을 위해 하기 함수들을 제공함
## renderToString
## renderToNodeStream
## renderToStaticMarkup
## rednerToStaticNodeStream
## renderToStaticMarkup과 rednerToStaticNodeStream 함수는 정적 페이지를 렌더링할 때 사용됨
## 최초 렌더링 이후에도 계속해서 상태 변화에 따라 화면을 갱신해야 하면 renderToString 또는 renderToNodeStream 함수를 사용해야 함

# 서버 사이드 렌더링에 필용한 패키지는 하기와 같음
## npm install express @babel/cli @babel/plugin-transform-modules-commonjs
### 웹 서버를 띄우기 위해 express 패키지를 설치함
### @babel/cli 패키지는 서버에서 사용될 자바스크립트 파일을 컴파일 할 때 사용됨
### 서버에서도 리액트의 JSX 문법으로 작성된 자바스크립트를 실행해야 하므로 바벨이 필요함
### ESM으로 작성된 모듈 시스템을 commonJS로 변경하기 위해 @babel/plugin-transform-modules-commonjs 패키지를 설치함
#### 서버에서는 노드 환경에서 자바스크립트를 실행하기 때문에 commonJS 모듈 시스템이 필요함

# react-dom/server 밑에 서버에서 사용되는 기능이 주요 존재함

# express 객체인 app 변수를 이용하여 미들웨어와 url 경로 설정이 가능함

# 서버 사이드 렌더링 시, 웹팩 빌드 후 생성된 특정 파일의 정보를 가져와, 이를 기반으로 새로운 HTML을 생성함
## 웹팩으로 빌드한 자바스크립트 파일이 이 코드에 의해 서비스됨

# renderToString 함수는 문자열을 반환함

# 서버와 클라이언트에 필요한 바벨 설정은 하기와 같음
## 클라이언트 : 바벨 프리셋(@babel/preset-react, @babel/preset-env), 바벨 플러그인 X
## 서버 : 바벨 프리셋(@babel/preset-react), 바벨 플러그인 (@babel/plugin-transform-modules-commonjs)
## @babel/preset-env는 주로 오래된 브라우저를 지우너하기 위한 용도로 사용됨
## 오래된 노드 버전을 사용하기 아니면 불필요하므로, 서버 측 바벨 설정에 포함하지 않음
## @babel/plugin-transform-modules-commonjs는 서버에서 실행하는 노드를 위해 필요함

# 웹팩 설정 파일에서는 HTML에 추가되는 번들 파일의 경로와 바벨 설정 파일의 경로를 수정해야 함
## publicPath 설정은 html-webpack-plugin이 HTML 생성 시 HTML 내부 리소스 파일의 경로를 만들 때 사용됨
### publicPath 설정 없이 생성된 HTML 파일은 브라우저에서 바로 실행하면 문제가 없으나 서버사이드 렌더링을 할 때는 문제가 존재함
### 이전에 server.js 파일에서 url이 /dist로 시작하는 경우에만 dist 폴더에 있는 파일을 서비스하도록 서정했으므로 publicPath도 같게 설정함
## 웹팩은 클라이언트 코드에 대해서만 실행할 예정으로 babel-loader가 클라이언트 설정으로 실행되도록 함

# 서버 측 코드는 @babel/cli를 이용해서 바벨만 실행하고, 클라이언트 측 코드는 웹팩을 실행함
## 앞으로 코드를 빌드하고 웹 서버를 띄우는 작업을 자주해야 하므로, package.json 내 script 옵션에 하기 내용을 추가함
### "build-server": "babel src --out-dir dist-server --config-file ./.babelrc.server.js" => 서버 측 코드를 빌드함, src 폴더 밑에 있는 모든 파일을 babelrc.server.js 설정으로 컴파일을 진행함
### "build": "npm run build-server && webpack", // 서버와 클라이언트 코드를 모두 빌드함, 클라이언트 측 빌드는 웹팩을 이용함
### "start": "node dist-server/server.js", // express 웹 서버를 띄우며 해당 명령은 빌드 후에 사용해야 함

# 서버 사이드 렌더링을 하면 이미 돔 요소가 만들어진 상태이므로 클라이언트 측에서 또다시 렌더링할 필요는 없음
## 하지만 각 돔 요소에 필요한 이벤트 처리 함수를 연결해야 함
### 이벤트 처리 함수를 연결하지 않으면 화면은 잘 보이나 사용자가 버튼을 눌러도 반응하지 않음
## 리액트에서 제공하는 hydrate 함수는 서버사이드 렌더링의 결과로 만들어진 돔 요소에 필요한 이벤트 처리 함수를 제공함

# 서버에서 렌더링할 때 사용한 데이터를 클라이언트도 알아야 일관성 있게 화면을 갱신할 수 있음
## HTML에 데이터를 넣기 위해선 서버는 __DATA_FROM_SERVER__ 부분에 데이터를 채워서 전달하고, 클라이언트는 window.__INITIAL_DATA__를 통해서 서버의 데이터를 받음
### 웹 서버 코드에서는 서버의 데이터를 HTML에서 삽입해야 함
#### 문자열로 된 주솟값을 구조체로 변환함 -> parsedUrl 변수는 url의 경로와 쿼리 파라미터 등의 정보를 가지고 있음

# 리덕스를 사용하는 프로젝트에서는 리덕스의 상탯값을 window.__INITIAL_DATA__로 전달하여 사용할 수 있음

# 리액트에서 스타일을 적용하는 방식은 다양하며, 전통적인 방식으로 CSS 파일을 별도로 작성 후 HTML 파일에 연결하면 서버사이드 렌더링 시 특별히 고민할 것은 없음
## 하지만 css-module이나 css-in-js 방식으로 작성한다면 서버사이드 렌더링 시 추가 작업을 진행해야 함
## 둘 다 자바스크립트 코드가 실행되면서 스타일 코드가 돔에 삽입되는 방식이므로 서버에는 돔이 없어 별도의 작업을 하지 않으면 서버사이드 렌더링 시, 스타일 정보가 HTML에 포함되지 않음

# styled-components로 스타일 적용
## npm install styled-components
## 스타일이 잘 적용된 것처럼 보여도 HTML에는 스타일 코드가 존재하지 않으며, 자바스크립트가 실행되지 않으면 스타일이 적용되지 않고, 검색 엔진에서는 스타일이 적용되지 않은 화면이 전달됨
### 먼저, 스타일을 추출하는 데 사용할 객체를 생성하고 collectStyles 메서드에 리액트 요소를 입력하면 스타일 정보를 수집하기 위한 코드가 리객트 요소에 삽입됨
#### 이 때, 실제 스타일 정보는 renderToString 함수의 호출이 끝나야 수집이 가능함
### getStyleTags 메서드를 호출하면 스타일 정보를 추출할 수 있음
### 스타일 정보가 HTML에 포함되어 전달되므로 사용자는 자바스크립트가 실행되지 않더라도 빠르게 스타일이 적용된 화면을 볼 수 있음

# 웹팩에서는 자바스크립트 파일 뿐만이 아닌 모든 파일이 모듈이 될 수 있음
## 이미지 파일은 대개 file-loader 또는 url-loader를 이용하여 처리함
### file-loader에게 전달된 리소스 파일은 output 설정에 지정된 폴더로 복사되며, 자바스크립트 코드에서는 복사된 파일의 경로가 반환됨
### 파일의 경로는 클라이언트와 서버가 모두 같은 정보를 공유해야 함 -> 그렇지 않으면 서버사이드 렌더링 결과가 클라이언트의 렌더링 결과와 달라서 문제가 됨
### 클라이언트 코드에서 file-loader로 처리된 리소스는 서버 코드에서 file-loader로 처리해야 하며, 서버 코드에서 file-loader를 실행하려면 서버 코드도 웹팩으로 번들링해야 함

# 서버 코드를 번들링할 때는 node_modules 폴더 밑에 있는 모듈까지 하나의 번들 파일로 만들 필요가 없음
## 서버 코드는 언제든지 node_modules 폴더 밑에 있는 모듈을 가져와서 사용할 수 있기 때문임
## webpack-node-externals 모듈은 node_modules 폴더 밑에 있는 모듈을 번들 파일에서 제외시켜 주는 역할을 함
## 웹팩 설정 파일에서 배열을 내보내면 배열의 각 아이템 갯수만큼 웹팩이 실행됨 -> 이 경우, 클라이언트 코드가 먼저 번들링되고, 서버 코드가 그 다음에 번들링됨

# 웹팩에 대한 대략적인 설정 내용은 하기와
## 클라이언트는 브라우저의 캐싱 효과 때문에 chunkhash를 사용하지만 서버는 필요 없음
## target 속성에 node를 입력해서 웹팩에 서버 코드를 번들링하는 것이라 알려줄 수 있음
### 웹팩은 node가 입력되면 노드에 특화된 번들링 과정을 거치며, fs, path 모듈과 같이 노드에 내장된 모듈을 번들 파일에 포함시키지 않음
## 서버 코드를 번들링할 때는 node_modules 폴더 밑에 있는 모듈을 버들 파일에 포함시키지 않도록 함

# 서버사이드 렌더링은 서버 리소스를 많이 사용하는데, 특히 렌더링 연산에 CPU가 많이 이용됨
## 한순간에 트래픽이 몰리면 모든 요청을 처리할 수 없음
## 높은 트래픽에 대응하는 방법은 여러가지이며, 프로젝트 상황에 맞게 적절한 방법을 사용해야 함

# 서버가 사용자의 요청에 가장 빠르게 응답하는 방법은 서버사이드 렌더링을 하지 않는 것임
## 평상시에는 서버사이드 렌더링을 진행하다가 서버 부하가 일정 수준을 넘어가면 서버사이드 렌더링을 포기하고 클라이언트 측에서만 렌더링하는 것도 한 가지 방법임
### 하지만 검색 엔진 최적화가 중요한 사이트라면 검색 엔진의 요청은 이런 상황이라도 서버사이드 렌더링을 하는 게 좋음
## 데이터 의존성이 낮은 페이지는 서버사이드 렌더링을 일부만 하는 방식으로 성능 문제를 해결할 수 있음
## 데이터 의존성이 전혀 없는 페이지는 빌드 시 미리 렌더링할 수 있음
## 사용자가 요청하면 단순히 정적 페이지를 서비스하면 되므로 서버 리소스를 절약할 수 있음
## 데이터에 의존성이 있더라도 그 범위가 작으면 해당하는 영역만 클라이언트 측에서 렌더링하도록 설계하면 됨
### 예시로 한쪽 모서리에 사용자 이름을 보여 주는 부분만 데이터에 의존적이면 그 부분만 클라이언트 측에서 렌더링하고 나머지 부분은 빌드 시 미리 렌더링이 가능함
#### 사용자 이름이 서버사이드 렌더링 시 존재하면 home 페이지는 사용자마다 다르므로 미리 렌더링이 어려움
#### 서버사이드 렌더링 시에는 사용자 이름 없이 렌더링하고, 클라이언트에서는 마운트 이후에 사용자 이름을 API로 받아오면 됨

# 데이터에 많이 의존적인 페이지는 정적 페이지를 미리 렌더링하는 방식을 사용할 수 없음
## 하지만 데이터가 자주 변하지 않는 페이지라면 서버사이드 렌더링 결과를 캐싱하여 사용할 수 있음
## 렌더링 결과를 1분만 캐싱해도 서버 부하를 크게 줄일 수 있음
### 1분 동안 수십만 페이지 뷰가 발생하더라도 단 한번만 서버사이드 렌더링을 하면 됨

# 제한된 메모리 안에 캐싱 데이터를 저장하려면 지울 데이터를 결정하는 알고리즘이 필요함
## npm install lru-cache
## lru-cache 패키지는 정해진 최대 캐시 갯수를 초고하면 LRU(Least Recently Used) 알고리즘에 따라 가장 오랫동안 사용되지 않은 캐시를 제거함

# 리액트는 서버사이드 렌더링을 위해 renderToString 함수 외에 renderToNodeStream 함수도 제공하고 있음
## renderToString 함수는 모든 렌더링 과정이 끝나야 문자열로 된 결괏값을 반환하지만, renderToNodeStream 함수는 호출 즉시 노드의 스트림 객체를 반환함
## renderToNodeStream 함수를 이용하면 렌더링 데이터를 빠르게 전달할 수 있다는 장점이 존재함
### 렌더링하려는 페이지가 아무리 복잡하더라도 첫 번재 청크가 준비되면 바로 전송을 시작하기 때문임

# 스트림은 배열이나 문자열과 같은 데이터 컬렉션이며, 크기가 큰 데이터를 다룰 때 유용함
## 스트림은 데이터를 청크 단위로 쪼개서 전달하므로 데이터가 완전히 준비되지 않아도 전송을 시작할 수 있음
## 스트림을 이용한 방법은 메모리를 효율적으로 사용할 뿐만이 아닌 첫 번째 청크가 준비되면 바로 전송을 시작하므로 데이터를 빠르게 전송할 수 있음
## 읽기와 쓰기 모두 가능한 스트림(duplex stream) 객체도 존재하며, 읽기와 쓰기가 모두 가능한 스트림은 세 개 이상의 스트림을 연결할 때 사용됨

# 스트림 방식에서 캐싱을 구현하기 위해선 스트림으로 전송되는 청크 데이터에 접근할 수 있어야 함
## 두 스트림 사이에 직접 구현한 스트림을 넣어야만 가능해짐

# 효율적인 개발을 위해서 서버사이드 렌더링을 구현할 수 있는 더 많은 기능이 필요함
## 이를 해결할 수단이 Next.js임

# 넥스트와 create-react-app은 리액트를 기반으로 개발 환경을 구축한다는 점에서 비슷하나 create-react-app은 클라이언트 렌더링만 하는 반면, 넥스트는 서버사이드 렌더링에 특화된 프레임워크라는 점이 다름
## 서버사이드 렌더링을 해야하는 직접 구축이 어렵다면 넥스트를 추천함

# 넥스트에선 모든 페이지 컴포넌트는 pages 폴더 밑에 만들어야 함

# 넥스트는 리액트 모듈을 자동으로 포함시켜주므로, 리액트 모듈을 가져오는 import 명령은 입력하지 않아도 됨

# 개발 모드로 넥스트를 실행하는 명령어는 npx next임
## 빌드 후, 개발자 모드로 확인해보면 서버사이드 렌더링된 결과가 응답값으로 오는 것을 알 수 있음
## 아무런 설정 없이 서버사이드 레더링이 되는 웹사이트를 제작함

# 프로덕션 모드로 빌드 후 실행하는 명령어는 npx next build && npx next start임
## 브라우저 내 다음과 같은 자바스크립트 파일이 전달됨
### [page].js : 작성한 페이지 코드가 들어 있음
### _app.js : 모든 페이지의 최상단에서 실행되는 리액트 컴포넌트 코드가 들어 있음
### framework.[해시값].js : 넥스트에서 사용하는 주요 패키지 (ex: 리액트)의 코드가 들어 있음
### [해시값].js : 여러 페이지에서 공통으로 사용하는 코드가 들어 있음
### main-[해시값].js : 웹팩 런타임 코드가 들어 있음

# .next/static 폴더 밑에는 다음과 같은 구조로 되어 있음
-.next/static
-- [해시값]
----pages
--chunks
--runtime
## pages 폴더에는 각 페이지의 번들 파일이 들어 있음
## chunks 폴더에는 여러 페이지에서 공통으로 사용하는 번들 파일이 들어 있음
## runtime 폴더에는 웹팩과 넥스트의 런타임과 관련된 모듈이 들어 있음

# .next/server/static 폴더 밑에는 다음과 같은 구조로 되어 있음
-.next/server/static
--[해시값]
---_app.js
---_document.js
---_error.js
---404.html
---[page].html
## .next/server/static 폴더 밑에는 서버에서 사용되는 파일이 들어감
### 이 폴더의 번들 파일은 코드가 압축되어 있지 않음
### node_modules 폴더 밑에 있는 외부 모듈의 코드가 번들 파일에 포함되어 있지 않음
#### 이는 이 폴더의 번들 파일이 서버에서 실행되는 코드이기 때문임
### [page] 페이지 파일이 자바스크립트가 아닌 HTML 파일인 것은 [page].js 파일은 변수를 사용하지 않아 렌더링 결과가 항상 같기 때문임
### 넥스트는 정적인 페이지를 자동으로 미리 렌더링하여 최적화함
### 넥스트는 동적인 페이지는 미리 렌더링하지 않으며, 자바스크립트 파일로 만듦
### _document.js 파일은 서버 측에서 HTML 요소를 추가하는 용도로 사용됨

# 프로젝트 루트 폴더의 static 폴더 밑에 정적 파일을 만들고 경로를 입력하면 정적 파일을 서비스할 수 있음
## 이 방식은 파일의 내용과 상관 없이 항상 같은 경로가 사용되므로 브라우저 캐싱 측면에선 불편한 점이 존재함

# 넥스트에서 제공하는 Head 컴포넌트를 사용하면 HTML head 태그에 원하는 돔 요소를 삽입할 수 있음
## 여러 번 사용하는 것도 가능하며, 나중에 하나로 합쳐짐

# 넥스트는 styled-jsx 패키지를 통해 css-in-js 방식을 지원함
## 선언된 스타일은 이 컴포넌트 내부에 존재하는 p 요소에만 적용됨
## styled-jsx를 사용하지 않고, styled-components와 같은 다른 패키지를 이용하는 것도 가능함

# 넥스트는 정적 파일을 서비스하기 위해 프로젝트 루트의 static 폴더를 이용함
## 현재 설정에선 정적 파일 내용과 관련 없이 항상 같은 파일 경로가 이용됨
## 브라우저 캐싱을 최대로 활용하기 위해서는 파일의 내용이 변경되면 파일의 경로도 변경되는 것이 좋음

# 넥스트는 프로젝트 루트의 .next 폴더 밑에 번들 파일을 생성함 

# 넥스트는 create-react-app과 다르게 웹팩 설정을 변경할 수 있음
## module.exports : 웹팩 설정을 변경하기 위한 함수 -> 이 함수의 첫 번째 매개변수로 넥스트의 웹팩 설정이 넘어옴
## config.module.rules.push : 넥스트 웹팩 설정에 file-loader를 추가함
## use-> loader-> options -> name: '[path][name].[ext]?[hash]', // 쿼리 파라미터 부분에 해시를 추가해서 파일의 내용이 변경될 때마다 파일의 경로도 수정하도록 함
## use-> loader-> options -> emitFile : 넥스트는 static 폴더의 정적 파일을 그대로 서비스하기 때문에 파일을 복사할 필요가 없음

# file-loader가 동작하려면 이미지를 모듈로 다뤄야 함

# 넥스트에서는 getInitalProps라는 함수를 이용하여 페이지 컴포넌트로 속성값을 전달함
## 각 페이지의 getInitalProps 함수는 페이지 진입 직전에 호출됨
## 사용자가 첫 페이지를 요청하면 getInitalProps 함수는 서버에서 호출됨
## 이후 클라이언트에서 페이지 전환을 하면 getInitalProps 함수는 클라이언트에서 호출됨
## getInitalProps 함수가 반환하는 값은 페이지 컴포넌트의 속성값으로 입력됨

# 넥스트는 getInitalProps 함수가 서버에서 호출되는 경우, 반환값을 클라이언트로 전달해줌
## getInitalProps 함수 내부의 API 호출은 서버 또는 클라이언트에서 호출될 수 있음
### async await 문법을 사용했으므로, API 통신이 끝날 때까지 기다림
## getInitalProps 함수가 반환하는 값은 페이지 컴포넌트의 속성값으로 전달됨

# getInitalProps 함수가 서버에서 호출되더라도 이 함수에서 생성된 데이터는 항상 페이지 컴포넌트로 잘 전달됨
## 서버에서 호출되는 경우를 특별히 신경 쓰지 않아도 되므로 getInitalProps 함수의 코드를 편하게 작성할 수 있음

# getInitalProps 함수의 매개변수로 다양한 정보가 전달되며, HTTP 요청과 응답 객체도 전달됨
## HTTP 요청과 응답 객체는 getInitalProps 함수가 서버에서 호출되는 경우에만 전달됨

# 넥스트는 페이지 이동을 위해 Link 컴포넌트와 Router 객체를 제공함
## 페이지 이동을 위해 Router 객체를 이용하는 것과 Link 컴포넌트를 이용하는 것 사이엔 큰 차이는 없으나 Router 객체가 좀 더 동적인 코드에 적합함

# 별도로 에러 페이지를 구현하지 않았다면 넥스트에서 기본으로 제공되는 에러 페이지가 사용됨
## 에러 페이지를 직접 구현하고 싶다면 _error.js 파일을 작성하면 됨

# 프로젝트의 규모가 커지면 코드 분할을 신경 써야 하고, 서버도 직접 띄어야 함
## 여러 페이지 컴포넌트의 공통 기능을 분리하는 방법이 필요하며, 넥스트에 내장된 styled-jsx보다는 css-in-js 분야에서 인지도가 높은 styled-components 등의 다른 패키지를 적용하는 방법도 고려해봐야 함
## 서버사이드 렌더링 시 CPU 연산을 최소화하는 게 중요한데, 이 때 렌더링 결과를 캐싱하거나 빌드 시 미리 렌더링하는 방법을 사용함

# 모든 페이지에서 공통으로 필요한 기능은 pages/_app.js 파일에서 구현할 수 있음
## 페이지가 전환되어도 메뉴 UI를 그대로 유지하고 싶으면 _app.js 파일에서 구현하는 것이 좋음
## 해당 컴포넌트는 페이지가 전환되는 경우에도 언마운트되지 않음
### 메뉴 UI는 항상 유지되어야 하므로, _app.js 파일에서 메뉴 UI를 구현하는 것이 자연스러움
### 컴포넌트가 언마운트되지 않으므로, MyApp 컴포넌트에서 전역 상탯값을 관리할 수 있음

# 넥스트는 기본적으로 페이지별로 번들 파일을 생성함
## 동적 임포트 사용 시에는 해당 모듈의 코드는 별도의 파일로 분할되며, 여러 페이지에 공통으로 사용되는 모듈도 별의 파일로 분할됨
## .next 폴더 내 static/chunks 폴더와 server 폴더 밑에 모듈의 코드를 포함하는 번들 파일이 존재함

# 동적 임포트를 사용하면 클라이언트 뿐만이 아닌 서버를 위한 번들 파일도 생성됨
## .next/server 폴더 밑에 생성되는 파일은 서버사이드 렌더링 시 사용됨
## 해당 모듈 코드를 가져오므로 클라이언트로 전달되므로 모듈 코드가 브라우저 내 존재함

# getInitalProps 함수가 서버 측에서 실행되면 클라이언트로 별도의 파일을 내려 줄 필요가 없으므로 모듈 코드가 브라우저 내 존재하지 않음
## 대신 getInitalProps 함수가 클라이언트에서 실행됨

# 넥스트는 여러 페이지에서 공통으로 사용되는 모듈을 별도의 번들 파일로 분할함
## 웹팩의 splitChunks 설정을 통해 코드를 분할하며, 코드 변경에 따른 캐시 무효화(Cache Invalidation)를 최소화하는 방향으로 설계되어 있음
## 해당 코드는 .next/static/chunks 폴더 밑에 있는 파일에 포함됨 -> 해당 청크 파일을 공통으로 사용함

# 내장된 웹 서버를 사용하지 않고, 웹 서버를 직접 띄우면 많은 작업이 가능함
## 예시로 내장된 웹 서버는 서버사이드 렌더링 결과를 캐싱할 수 없으나 직접 띄운 웹 서버에서는 캐싱을 통해 보다 많은 트래픽을 처리할 수 있음
## 실행 명령어는 node server.js이며, 빌드 후의 실행 명령어는 npx next build && NODE_ENV=production node server.js임

# 페이지를 미리 렌더링하면 서버의 CPU 리소스를 절약할 수 있음
## 넥스트에서 빌드 시 getInitalProps 함수가 없는 페이지는 자동으로 미리 렌더링됨
### .next/server/static 폴더를 확인해보면, 각각 HTML과 JS 파일로 렌더링되어 만들어지는 것을 확인할 수 있음
## getInitalProps 함수는 꼭 필요한 경우에만 작성하는 것이 좋으며 만약 _app.js 파일에서 getInitalProps 함수를 정의하면 모든 페이지가 미리 렌더링되지 않으므로 주의하는 것이 좋음

# 넥스트에서는 next export 명령어를 통해 전체 페이지를 미리 렌더링할 수 있음
## next export 명령어는 빌드 후에 실행해야 함 -> npx next build && npx next export

# 미리 렌더링된 구조는 하기와 같음
out
- 404.html
- page1.html
- page2.html
- _next
- static
-- icon.png
## 404.html : 에러 페이지가 미리 렌더링된 파일임
## page1.html : /page1 요청에 대해 미리 렌더링된 파일임
## page2.html : /page2 요청에 대해 미리 렌더링된 파일임
## _next 폴더 : 프로젝트 루트의 .next 폴더에 있는 번들 파일과 같음
## static 폴더 : 이미지와 같은 정적 파일을 모아 놓은 폴더임
## next export 명령어 실행 후 생성된 out 폴더만 있으면 서버에서 넥스트를 실행하지 않고 정적 페이지를 서비스할 수 있음

# 미리 렌더링된 정적 파일의 경우 쿼리 파라미터가 적용되지 않음
## 넥스트에서는 쿼리 파라미터도 미리 설정할 수 있는 옵션을 제공해줌

# 넥스트의 exportPathMap 옵션을 이용하면 쿼리 파라미터를 활용해서 정적 페이지를 만들 수 있음
## 특정 쿼리 파라미터에 대한 주소는 접근이 가능하나, 쿼리 파라미터가 존재하지 않는 주소는 접근이 안 됨
### 이는 동적과 정적 페이지를 동시에 서비스하는 방식으로 해결 가능함